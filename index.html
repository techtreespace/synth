<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DIY 아날로그 신디사이저 탐험</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f0f0; /* Light gray background */
        }
        .tab-button {
            @apply px-4 py-2 font-semibold rounded-t-lg transition-colors duration-200 ease-in-out;
        }
        .tab-button.active {
            @apply bg-sky-600 text-white;
        }
        .tab-button:not(.active) {
            @apply text-sky-700 bg-sky-100 hover:bg-sky-200;
        }
        .content-section {
            /* 기존 min-h-[400px] 제거, flex-grow와 overflow-y-auto 추가 */
            @apply p-6 bg-white rounded-b-lg rounded-tr-lg shadow-lg flex-grow overflow-y-auto flex flex-col;
        }
        .interactive-box {
            @apply border-2 border-dashed border-amber-500 p-4 rounded-lg mt-4 text-center;
        }
        .component-card {
            @apply bg-stone-100 p-4 rounded-lg shadow hover:shadow-md transition-shadow;
        }
        .chart-container {
            position: relative;
            width: 100%;
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
            height: 200px;
            max-height: 250px;
            background-color: #f0f0f0;
            border-radius: 0.5rem;
        }
        @media (min-width: 768px) {
            .chart-container {
                height: 250px;
            }
        }
        /* 추가된 CSS: 텍스트 선택 방지 */
        .synth-button, #tactSwitchDemo {
            -webkit-user-select: none; /* Safari */
            -ms-user-select: none; /* IE 10+ */
            user-select: none; /* Standard syntax */
            touch-action: manipulation; /* 터치 이벤트 최적화: 탭 지연 제거 및 확대/확대 방지 */
        }
        /* 건반 버튼 크기 고정 및 내용 중앙 정렬 */
        .synth-button {
            @apply w-24 h-20 flex items-center justify-center text-white text-lg font-bold; /* 고정된 크기와 중앙 정렬 */
            flex-shrink: 0; /* 공간이 부족해도 줄어들지 않도록 함 */
            background-image: linear-gradient(to bottom, #d1d5db, #6b7280); /* 기본 회색 그라데이션 */
        }
        /* Heart section canvas styling */
        .heart-canvas-container {
            height: 100px; /* Fixed height for animation canvases */
            width: 100%;
            background-color: #e0f2fe; /* Light blue background for clarity */
            border-radius: 0.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden; /* Ensure waves don't overflow */
        }
    </style>
</head>
<body class="flex flex-col min-h-screen bg-amber-50 text-stone-800 overflow-x-hidden">
    <header class="flex-shrink-0 bg-sky-700 text-white p-6 shadow-md sticky top-0 z-50">
        <div class="container mx-auto flex flex-col sm:flex-row justify-between items-center">
            <h1 class="text-3xl font-bold">DIY 아날로그 신디사이저 탐험</h1>
            <nav class="mt-4 sm:mt-0">
                <button class="tab-button active" onclick="showSection('sound')">1. 소리의 세계</button>
                <button class="tab-button" onclick="showSection('heart')">2. 신디사이저의 심장</button>
                <button class="tab-button" onclick="showSection('hands')">3. 신디사이저의 손과 발</button>
                <button class="tab-button" onclick="showSection('play')">4. 나만의 신디사이저 연주!</button>
                <button class="tab-button" onclick="showSection('summary')">5. 핵심 정리</button>
            </nav>
        </div>
    </header>

    <main class="flex-grow container mx-auto px-4 sm:px-8 lg:px-16 max-w-7xl flex flex-col overflow-hidden">
        <div id="sound" class="content-section">
            <h2 class="text-2xl font-bold text-sky-700 mb-4">1. 소리의 세계 🌍</h2>
            <p class="mb-4">이 섹션에서는 우리 주변의 '소리'가 무엇인지, 어떻게 만들어지고 우리가 어떻게 듣게 되는지 기본적인 원리를 탐험합니다. 신디사이저를 이해하기 위한 첫걸음, 시작해볼까요?</p>
            
            <div class="grid md:grid-cols-2 gap-6">
                <div class="component-card">
                    <h3 class="text-xl font-semibold text-emerald-700 mb-2">소리의 발생 원리</h3>
                    <p>소리는 물체가 <strong class="text-amber-600">진동</strong>해서 만들어지는 에너지의 한 형태예요. 기타 줄을 튕기면 줄이 떨리죠? 이 떨림(진동)이 공기를 흔들어 우리 귀에 닿으면 소리로 인식된답니다. 마치 물 위에 돌을 던졌을 때 물결이 퍼져나가는 것과 비슷해요!</p>
                </div>
                <div class="component-card">
                    <h3 class="text-xl font-semibold text-emerald-700 mb-2">소리의 높낮이 (음고)</h3>
                    <p>소리의 높낮이는 진동이 얼마나 <strong class="text-amber-600">빠르게</strong> 일어나는지에 따라 결정돼요. 진동이 빠르면 높은 소리(고음), 느리면 낮은 소리(저음)가 나죠. 1초에 몇 번 진동하는지를 나타내는 단위를 <strong class="text-amber-600">주파수(Hz)</strong>라고 해요. 주파수가 높을수록 높은 소리가 납니다!</p>
                </div>
            </div>

<div class="interactive-box mt-6">
    <h4 class="text-lg font-semibold mb-2">주파수 조절 체험</h4>
    
    <div class="flex flex-col md:flex-row items-center justify-center gap-4">
        <div class="chart-container mt-4 md:mt-0 w-full md:w-1/2">
            <canvas id="waveCanvas"></canvas>
        </div>
        
        <div class="w-full md:w-1/2 flex flex-col items-center">
            <p class="mb-2 text-sm text-center">아래 슬라이더를 움직여 주파수를 조절해보세요.<br> 주파수에 따라 파형이 어떻게 변하고 소리가 어떻게 달라지는지 관찰해봅시다!</p>
            <input type="range" id="frequencySlider" min="1" max="20" value="5" class="w-full max-w-md mx-auto accent-amber-500">
            <p class="mt-2">현재 주파수 단계: <span id="frequencyValue" class="font-bold text-sky-600">5</span></p>
            <p id="pitchDescription" class="mt-2 font-semibold h-6"></p> </div>
    </div>
</div>
        </div>

        <div id="heart" class="content-section hidden">
            <h2 class="text-2xl font-bold text-sky-700 mb-4">2. 신디사이저의 심장: 555 타이머, 슈미트 트리거, OP-AM❤️</h2>
            <p class="mb-4">신디사이저가 소리를 내는 데에는 핵심적인 역할을 하는 부품, '555 타이머', '슈미트 트리거'와 'OP-AMP'가 어떻게 신디사이저의 심장처럼 작동하는지 알아봅시다!</p>
            <div class="grid md:grid-cols-2 gap-6">
                <div class="component-card">
                    <h3 class="text-xl font-semibold text-emerald-700 mb-2">555 타이머: 소리의 박자를 만드는 지휘자</h3>
                    <p><strong class="text-amber-600">555 타이머</strong>는 규칙적인 <strong class="text-amber-600">전기 신호(펄스)</strong>를 만들어내는 부품이에요.<br> 우리 신디사이저에서는 이 펄스의 빠르기를 조절해서 소리의 높낮이, 즉 <strong class="text-amber-600">주파수</strong>를 결정하는 핵심 역할을 해요. 마치 물통에 물을 채웠다 비우는 것을 반복하며 일정한 간격을 만들어내는 것과 비슷하답니다.</p>
                    <div class="heart-canvas-container mt-2">
                        <canvas id="timerAnimationCanvas"></canvas>
                    </div>
                </div>
                <div class="component-card">
                    <h3 class="text-xl font-semibold text-emerald-700 mb-2">슈미트 트리거: 깨끗한 펄스 생성기</h3>
                    <p><strong class="text-amber-600">슈미트 트리거(Schmitt Trigger)</strong>는 불안정한 아날로그 신호를 깨끗하고 안정적인 <strong class="text-amber-600">사각파 펄스</strong>로 변환하는 데 사용돼요.<br> 특정 전압(임계값)을 넘으면 출력이 바뀌는 방식으로, 발진 회로를 구성하여 직접 소리(사각파)를 만들 수 있습니다.</p>
                    <div class="heart-canvas-container mt-2">
                        <canvas id="schmittTriggerAnimationCanvas"></canvas>
                    </div>
                </div>
                <div class="component-card">
                    <h3 class="text-xl font-semibold text-emerald-700 mb-2">OP-AMP (연산 증폭기): 소리를 키워주는 스피커</h3>
                    <p>555 타이머가 만든 소리 신호는 아직 너무 작아서 잘 들리지 않아요. 이때 OP-AMP가 등장합니다! OP-AMP는 이 작은 신호를 <strong class="text-amber-600">아주 크게 키워주는(증폭하는)</strong> 역할을 해요. 마이크로 목소리를 크게 만드는 것처럼요.<br> 덕분에 우리는 신디사이저 소리를 스피커로 들을 수 있게 된답니다.</p>
                    <div id="opampAnimation" class="mt-2 h-16 bg-emerald-100 rounded flex items-center justify-center text-sm text-emerald-700">
                        신호 증폭 중... (소리가 커집니다!)
                    </div>
                </div>
            </div>
        </div>

        <div id="hands" class="content-section hidden">
            <h2 class="text-2xl font-bold text-sky-700 mb-4">3. 신디사이저의 손과 발: 주요 부품들 🖐️🦶</h2>
            <p class="mb-4">신디사이저를 직접 조작하고 소리를 다양하게 만들기 위해 전기 흐름을 조절하는 '저항', 소리 높낮이를 바꾸는 '가변저항', 소리를 켜고 끄는 '택트 스위치'에 대해 알아볼까요?</p>
            <div class="grid md:grid-cols-3 gap-6">
                <div class="component-card">
                    <h3 class="text-xl font-semibold text-emerald-700 mb-2">저항: 전기 흐름의 문지기 & 펄스 폭 조절</h3>
                    <p>저항은 전기 회로에서 전류의 양을 조절하거나 전압을 나누는 역할을 해요. 마치 수도꼭지로 물의 양을 조절하듯, 저항은 전기 에너지의 흐름을 <strong class="text-amber-600">적절하게 제어</strong>합니다. 555 타이머의 작동 속도 조절에도 관여해요.</p>
                    <p class="mt-2 text-sm">또한, 사각파의 <strong class="text-amber-600">펄스 폭(Duty Cycle)</strong>은 파형이 '켜져 있는' 시간의 비율을 의미하며, 이는 소리의 <strong class="text-amber-600">음색(Timbre)</strong>을 변화시킵니다. 555 타이머와 같은 발진 회로에서는 저항값을 조절하여 이 펄스 폭을 변경할 수 있습니다. 예를 들어, 펄스 폭이 좁아지면 날카로운 소리가, 넓어지면 더 풍부한 소리가 날 수 있습니다.</p>
                    <div class="interactive-box mt-4">
                        <h4 class="text-lg font-semibold mb-2">펄스 폭 조절 체험</h4>
                        <label for="handsPulseWidthKnob" class="block text-sm font-medium text-gray-700 mb-1">펄스 폭 (듀티 사이클): <span id="handsPulseWidthValue" class="font-bold text-sky-600">50</span>%</label>
                        <input type="range" id="handsPulseWidthKnob" min="10" max="90" value="50" class="w-full accent-purple-500">
                        <div class="chart-container mt-4 h-24 max-h-24">
                            <canvas id="handsPulseWidthCanvas"></canvas>
                        </div>
                    </div>
                </div>
                <div class="component-card">
                    <h3 class="text-xl font-semibold text-emerald-700 mb-2">가변저항: 소리 높낮이 마법사</h3>
                    <p>가변저항은 손잡이를 돌리거나 슬라이드를 움직여 저항값을 바꿀 수 있는 특별한 저항이에요. 신디사이저에서는 이 가변저항을 이용하여 555 타이머에 연결된 저항값을 변화시키고, 결과적으로 <strong class="text-amber-600">소리의 높낮이를 마음대로 조절</strong>할 수 있게 해줍니다. 라디오 볼륨 조절기처럼요!</p>
                     <div class="interactive-box mt-2">
                        <label for="potentiometerDemo" class="block text-sm font-medium text-gray-700">가변저항 체험: <span id="potentiometerValue" class="font-bold text-sky-600">50</span>%</label>
                        <input type="range" id="potentiometerDemo" min="0" max="100" value="50" class="w-full accent-amber-500 mt-1">
                    </div>
                </div>
                <div class="component-card">
                    <h3 class="text-xl font-semibold text-emerald-700 mb-2">택트 스위치: 소리 재생 버튼</h3>
                    <p>택트 스위치는 누르면 회로가 연결되어 소리가 나고, 손을 떼면 회로가 끊어져 소리가 멈추는 <strong class="text-amber-600">버튼</strong>이에요. 전등 스위치처럼 전기의 길을 열었다 닫았다 하며 신디사이저 소리를 제어합니다.</p>
                    <div class="interactive-box mt-2">
                        <button id="tactSwitchDemo" class="bg-sky-500 hover:bg-sky-600 text-white font-bold py-2 px-4 rounded transition-colors">
                            스위치 누르기!
                        </button>
                        <p id="tactSwitchStatus" class="text-sm mt-1">스위치 상태: 꺼짐 (마우스 클릭 또는 스페이스바 키로 조작)</p>
                    </div>
                </div>
            </div>
        </div>

        <div id="play" class="content-section hidden">
            <h2 class="text-2xl font-bold text-sky-700 mb-4">4. 나만의 신디사이저 연주! 🎹✨</h2>
            <p class="mb-4">지금까지 배운 내용을 바탕으로 신디사이저를 연주해봅시다! 가변저항으로 음높이를 조절하고, 택트 스위치로 소리를 내보세요.</p>
            
            <div class="bg-stone-200 p-4 rounded-lg shadow-inner max-w-2xl mx-auto flex flex-col flex-grow"> <h3 class="text-xl font-semibold text-center text-stone-700 mb-4">아날로그 신디사이저 시뮬레이터</h3>
                
                <div class="flex flex-col items-center space-y-4 flex-grow"> <div class="flex flex-wrap justify-center gap-4 mb-4">
                        <label class="inline-flex items-center">
                            <input type="radio" name="waveformType" value="sine" class="form-radio text-sky-600 accent-sky-600" checked>
                            <span class="ml-2 text-sm font-medium text-gray-700">사인파 (Sine)</span>
                        </label>
                        <label class="inline-flex items-center">
                            <input type="radio" name="waveformType" value="square" class="form-radio text-sky-600 accent-sky-600">
                            <span class="ml-2 text-sm font-medium text-gray-700">사각파 (Square)</span>
                        </label>
                        <label class="inline-flex items-center">
                            <input type="radio" name="waveformType" value="sawtooth" class="form-radio text-sky-600 accent-sky-600">
                            <span class="ml-2 text-sm font-medium text-gray-700">톱니파 (Sawtooth)</span>
                        </label>
                        <label class="inline-flex items-center">
                            <input type="radio" name="waveformType" value="triangle" class="form-radio text-sky-600 accent-sky-600">
                            <span class="ml-2 text-sm font-medium text-gray-700">삼각파 (Triangle)</span>
                        </label>
                    </div>

                    <div class="flex flex-col md:flex-row items-center justify-center gap-4 w-full">
                        <div class="chart-container w-full md:w-1/2 h-48"> <canvas id="synthOutputCanvas"></canvas>
                        </div>
                        
                        <div class="w-full md:w-1/2 flex flex-col items-center space-y-4">
                            <div id="pulseWidthControl" class="w-full max-w-xs"> <label for="pulseWidthKnob" class="block text-sm font-medium text-gray-700 mb-1">펄스 폭 조절 (듀티 사이클):</label>
                                <input type="range" id="pulseWidthKnob" min="10" max="90" value="50" class="w-full accent-purple-500">
                                <p class="text-xs text-center mt-1">현재 값: <span id="pulseWidthValue" class="font-bold">50</span>%</p>
                            </div>

                            <div class="w-full max-w-xs"> <label for="synthPitchKnob" class="block text-sm font-medium text-gray-700 mb-1">음높이 조절 (가변저항):</label>
                                <input type="range" id="synthPitchKnob" min="1" max="100" value="50" class="w-full accent-amber-500">
                                <p class="text-xs text-center mt-1">현재 값: <span id="synthPitchValue" class="font-bold">50</span></p>
                            </div>
                        </div>
                    </div>
                    
                    <p id="synthOutputStatus" class="mt-2 text-center font-semibold text-stone-700 h-6"></p>

                    <div class="flex flex-col gap-4 w-full items-center">
                        <div class="flex flex-wrap justify-center gap-4">
                            <button class="synth-button rounded-lg shadow transition-transform hover:scale-105" data-note-full="C5">도</button>
                            <button class="synth-button rounded-lg shadow transition-transform hover:scale-105" data-note-full="D5">레</button>
                            <button class="synth-button rounded-lg shadow transition-transform hover:scale-105" data-note-full="E5">미</button>
                            <button class="synth-button rounded-lg shadow transition-transform hover:scale-105" data-note-full="F5">파</button>
                            <button class="synth-button rounded-lg shadow transition-transform hover:scale-105" data-note-full="G5">솔</button>
                            <button class="synth-button rounded-lg shadow transition-transform hover:scale-105" data-note-full="A5">라</button>
                            <button class="synth-button rounded-lg shadow transition-transform hover:scale-105" data-note-full="B5">시</button>
                        </div>
                        <div class="flex flex-wrap justify-center gap-4">
                            <button class="synth-button rounded-lg shadow transition-transform hover:scale-105" data-note-full="C4">도</button>
                            <button class="synth-button rounded-lg shadow transition-transform hover:scale-105" data-note-full="D4">레</button>
                            <button class="synth-button rounded-lg shadow transition-transform hover:scale-105" data-note-full="E4">미</button>
                            <button class="synth-button rounded-lg shadow transition-transform hover:scale-105" data-note-full="F4">파</button>
                            <button class="synth-button rounded-lg shadow transition-transform hover:scale-105" data-note-full="G4">솔</button>
                            <button class="synth-button rounded-lg shadow transition-transform hover:scale-105" data-note-full="A4">라</button>
                            <button class="synth-button rounded-lg shadow transition-transform hover:scale-105" data-note-full="B4">시</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div id="summary" class="content-section hidden">
            <h2 class="text-2xl font-bold text-sky-700 mb-4">5. 핵심 정리 및 학습 💡</h2>
            <p class="mb-4">오늘 우리는 소리의 신비로운 세계부터 신디사이저의 작동 원리까지 많은 것을 배웠어요. 이 섹션에서는 주요 내용을 다시 한번 정리하고, 앞으로 더 재미있게 전자공학을 탐구할 수 있는 몇 가지 팁을 알려줄게요!</p>
            
            <div class="space-y-4">
                <div class="component-card">
                    <h3 class="text-xl font-semibold text-emerald-700 mb-2">오늘 배운 핵심 내용:</h3>
                    <ul class="list-disc list-inside space-y-1 text-sm">
                        <li>소리는 물체의 <strong class="text-amber-600">진동</strong>으로 발생하며, 진동 속도(주파수)에 따라 높낮이가 결정돼요.</li>
                        <li><strong class="text-amber-600">555 타이머</strong>는 규칙적인 신호를 만들어 소리의 기본 주파수를 생성해요.</li>
                        <li><strong class="text-amber-600">슈미트 트리거</strong>는 불안정한 신호를 깨끗한 사각파 펄스로 변환하여 소리를 명확하게 만들어줘요.</li>
                        <li><strong class="text-amber-600">OP-AMP</strong>는 작은 소리 신호를 크게 증폭시켜 우리가 들을 수 있게 해요.</li>
                        <li><strong class="text-amber-600">저항</strong>은 전류를 제어하고, <strong class="text-amber-600">가변저항</strong>으로 음높이를 조절하며, <strong class="text-amber-600">택트 스위치</strong>로 소리를 켜고 끌 수 있어요.</li>
                        <li>이 모든 부품들이 모여 신디사이저라는 악기가 된답니다!</li>
                    </ul>
                </div>
                 <div class="component-card">
                    <h3 class="text-xl font-semibold text-emerald-700 mb-2">학습 진행 팁 (from 교육과정):</h3>
                    <ul class="list-disc list-inside space-y-1 text-sm">
                        <li><strong>시각 자료 활용:</strong> 그림이나 애니메이션을 보면 이해가 더 쉬워요. (이 앱처럼요!)</li>
                        <li><strong>비유와 실생활 예시:</strong> 어려운 원리도 주변의 물건에 비유하면 재미있게 배울 수 있어요.</li>
                        <li><strong>질문은 언제나 환영:</strong> 궁금한 점이 있다면 주저하지 말고 질문하세요!</li>
                        <li><strong>직접 체험하기:</strong> 직접 만져보고 조작해보는 것이 최고의 학습 방법이에요.</li>
                        <li><strong>안전 제일:</strong> 전자 부품을 다룰 때는 항상 안전 수칙을 지켜주세요.</li>
                    </ul>
                </div>
                <p class="mt-4 text-center font-semibold">여러분의 창의력과 호기심으로 더 멋진 소리와 장치들을 만들어보세요! 🚀</p>
            </div>
        </div>
    </main>

    <footer class="text-center p-4 text-sm text-sky-800 mt-8">
        © 2025 DIY 신디사이저 학습 도우미. 즐거운 탐험 되세요!
    </footer>

    <script>
        const sections = ['sound', 'heart', 'hands', 'play', 'summary'];
        const tabButtons = document.querySelectorAll('.tab-button');
        const contentSections = document.querySelectorAll('.content-section');
        let currentActiveSectionId = 'sound'; // 현재 활성화된 섹션 ID를 추적하는 변수

        // 애니메이션 프레임 ID를 저장하여 중지할 수 있도록 합니다.
        window.timerAnimationId = null; // 'let' 제거 및 window 객체에 할당
        window.schmittAnimationId = null; // 'let' 제거 및 window 객체에 할당

        function showSection(sectionId) {
            // 모든 섹션 숨기기
            contentSections.forEach(section => {
                section.classList.add('hidden');
            });
            // 선택된 섹션 보이기
            document.getElementById(sectionId).classList.remove('hidden');

            // 탭 버튼 활성화 상태 업데이트
            tabButtons.forEach(button => {
                button.classList.remove('active');
                if (button.getAttribute('onclick').includes(sectionId)) {
                    button.classList.add('active');
                }
            });
            currentActiveSectionId = sectionId; // 현재 활성화된 섹션 업데이트
            window.scrollTo(0, 0); // 스크롤 맨 위로

            // 섹션에 따라 캔버스 초기화 또는 애니메이션 시작/중지
            if (sectionId === 'sound') {
                setupWaveCanvas();
            } else if (sectionId === 'play') {
                setupSynthCanvas();
                // 'play' 섹션으로 이동 시, 현재 선택된 파형에 따라 펄스 폭 조절 UI 표시/숨김
                const waveformRadios = document.querySelectorAll('input[name="waveformType"]');
                let selectedRadio = Array.from(waveformRadios).find(radio => radio.checked);
                if (selectedRadio && selectedRadio.value === 'square') {
                    pulseWidthControl.classList.remove('hidden');
                } else {
                    pulseWidthControl.classList.add('hidden');
                }
            } else if (sectionId === 'hands') {
                setupHandsPulseWidthCanvas();
            }


            // Heart 섹션 애니메이션 제어
            if (sectionId === 'heart') {
                startHeartAnimations();
            } else {
                stopHeartAnimations();
            }
        }

        let audioContext;
        let oscillator;
        let gainNode;
        let currentPlayingBaseFreq = 0; // 섹션 4에서 현재 재생 중인 음의 기본 주파수를 저장

        function initAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                gainNode = audioContext.createGain();
                gainNode.connect(audioContext.destination);
                gainNode.gain.setValueAtTime(0, audioContext.currentTime);
            }
            // 오디오 컨텍스트가 일시 중지된 경우 재개
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
        }

        // 선택된 파형 타입을 저장하는 전역 변수
        let selectedWaveformType = 'sine'; // 기본값은 사인파

        // Helper function to create a PeriodicWave for a square wave with variable duty cycle
        function createSquarePeriodicWave(audioContext, dutyCycle) {
            const numHarmonics = 2048; // Number of harmonics
            const real = new Float32Array(numHarmonics + 1);
            const imag = new Float32Array(numHarmonics + 1);

            real[0] = 0; // DC component
            imag[0] = 0;

            for (let k = 1; k <= numHarmonics; k++) {
                const nPiD = k * Math.PI * dutyCycle;
                real[k] = (2 / (k * Math.PI)) * Math.sin(nPiD);
                imag[k] = (2 / (k * Math.PI)) * (1 - Math.cos(nPiD));
            }
            return audioContext.createPeriodicWave(real, imag, { disableNormalization: true });
        }

        function playTone(frequency, duration = 0.1, dutyCycle = 0.5) { // Add dutyCycle parameter
            initAudio();
            // 기존 오실레이터가 있다면 중지하고 연결 해제
            if (oscillator) {
                try {
                    oscillator.stop();
                    oscillator.disconnect();
                } catch (e) { /* 이미 중지되었거나 연결 해제된 경우 무시 */ }
            }
            oscillator = audioContext.createOscillator();

            if (selectedWaveformType === 'square') {
                // 사각파의 경우 PeriodicWave를 사용하여 듀티 사이클을 적용
                const periodicWave = createSquarePeriodicWave(audioContext, dutyCycle);
                oscillator.setPeriodicWave(periodicWave);
            } else {
                // 다른 파형의 경우 oscillator.type 사용
                oscillator.type = selectedWaveformType;
            }

            // frequency가 유효한 숫자인지 확인
            if (!isFinite(frequency)) {
                console.error("Invalid frequency value:", frequency);
                return; // 유효하지 않은 주파수 값일 경우 재생 중단
            }
            oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
            
            oscillator.connect(gainNode);
            // 부드러운 시작을 위한 게인 조절
            gainNode.gain.linearRampToValueAtTime(0.5, audioContext.currentTime + 0.01);
            oscillator.start();

            if (duration > 0) {
                // 지정된 시간 후 부드럽게 소리 끄기
                gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + duration);
                oscillator.stop(audioContext.currentTime + duration);
            }
        }

        function stopTone() {
            // oscillator가 존재하고, 시작된 상태인지 확인 (stop 호출 전에 start가 호출되었는지)
            if (oscillator && audioContext && audioContext.state === 'running' && oscillator.playbackState !== 3 /* AudioBufferSourceNode.ENDED */) {
                // 부드러운 종료를 위한 게인 조절
                gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.01);
                // 게인 감소 후 오실레이터 중지
                oscillator.stop(audioContext.currentTime + 0.02);
                oscillator.disconnect();
                oscillator = null;
            }
        }

        const frequencySlider = document.getElementById('frequencySlider');
        const frequencyValue = document.getElementById('frequencyValue');
        const pitchDescription = document.getElementById('pitchDescription');
        let waveCanvas; 
        let waveCtx;    

        function drawWave(frequency) {
            // 캔버스 컨텍스트가 준비되지 않았다면 함수 종료
            if (!waveCtx || !waveCanvas) return; 

            const width = waveCanvas.width;
            const height = waveCanvas.height;
            const amplitude = height / 3;
            const centerY = height / 2;
            
            waveCtx.clearRect(0, 0, width, height); // 캔버스 지우기
            waveCtx.beginPath(); // 새로운 경로 시작
            waveCtx.moveTo(0, centerY); // 시작점 설정

            // 사인파 그리기
            for (let x = 0; x < width; x++) {
                const y = centerY + amplitude * Math.sin((x * frequency * Math.PI * 2) / (width * 5));
                waveCtx.lineTo(x, y);
            }
            waveCtx.strokeStyle = 'rgb(59, 130, 246)'; // 파란색 선
            waveCtx.lineWidth = 2; // 선 두께
            waveCtx.stroke(); // 선 그리기
        }
        
        function setupWaveCanvas() {
            waveCanvas = document.getElementById('waveCanvas'); 
            if (waveCanvas) { 
                waveCtx = waveCanvas.getContext('2d'); 
                const container = waveCanvas.parentElement;
                waveCanvas.width = container.clientWidth;
                waveCanvas.height = container.clientHeight;
                drawWave(parseInt(frequencySlider.value)); // 초기 파형 그리기
            }
        }

        frequencySlider.addEventListener('input', (event) => {
            const freq = parseInt(event.target.value);
            frequencyValue.textContent = freq;
            drawWave(freq); // 슬라이더 값에 따라 파형 업데이트
            // 주파수 값에 따른 음높이 설명 업데이트
            if (freq < 7) pitchDescription.textContent = "낮은 음 (저주파)";
            else if (freq < 14) pitchDescription.textContent = "중간 음";
            else pitchDescription.textContent = "높은 음 (고주파)";

            const audioFreq = 100 + (freq - 1) * 50;
            playTone(audioFreq, 0); // 소리 재생 (무한 재생)
        });

        // 마우스/터치 이벤트 종료 시 소리 멈춤
        frequencySlider.addEventListener('mouseup', () => {
            stopTone();
        });
        frequencySlider.addEventListener('touchend', () => {
            stopTone();
        });
        frequencySlider.addEventListener('mouseleave', () => {
            stopTone();
        });
        
        // Heart 섹션 애니메이션 관련 변수 및 함수
        let timerAnimationCanvas, timerAnimationCtx;
        let schmittTriggerAnimationCanvas, schmittTriggerAnimationCtx;
        let animationTime = 0; // 애니메이션 시간 추적

        function drawHeartWaveform(ctx, canvas, type, time) {
            const width = canvas.width;
            const height = canvas.height;
            const amplitude = height / 3;
            const centerY = height / 2;
            const flowSpeed = 0.5; // 파형이 흘러가는 속도 조절

            ctx.clearRect(0, 0, width, height);
            ctx.beginPath();
            ctx.moveTo(0, centerY);

            // 파형을 흐르게 하기 위해 시간(time)을 x 축에 더해 위상 변화를 줍니다.
            // Math.PI * 4는 캔버스 너비에 2주기(cycle)가 보이도록 설정
            for (let x = 0; x < width; x++) {
                let y;
                const angle = ((x / width) * Math.PI * 4) + (time * flowSpeed); 

                if (type === 'pulse') {
                    // 펄스 파형 (낮은 듀티 사이클의 사각파)
                    y = centerY + amplitude * (Math.sin(angle) > 0.8 ? 1 : -1); // 좁은 펄스
                } else if (type === 'square') {
                    // 사각파 파형 (50% 듀티 사이클)
                    y = centerY + amplitude * (Math.sin(angle) > 0 ? 1 : -1);
                }
                ctx.lineTo(x, y);
            }
            ctx.strokeStyle = 'rgb(59, 130, 246)';
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        function animateHeartWaves() {
            animationTime += 0.1; // 시간 증가량 조절
            if (timerAnimationCtx && timerAnimationCanvas) {
                drawHeartWaveform(timerAnimationCtx, timerAnimationCanvas, 'pulse', animationTime);
            }
            if (schmittTriggerAnimationCtx && schmittTriggerAnimationCanvas) {
                drawHeartWaveform(schmittTriggerAnimationCtx, schmittTriggerAnimationCanvas, 'square', animationTime);
            }
            window.timerAnimationId = requestAnimationFrame(animateHeartWaves); // window 객체에 할당
        }

        function setupHeartCanvases() {
            timerAnimationCanvas = document.getElementById('timerAnimationCanvas');
            schmittTriggerAnimationCanvas = document.getElementById('schmittTriggerAnimationCanvas');

            if (timerAnimationCanvas) {
                timerAnimationCtx = timerAnimationCanvas.getContext('2d');
                timerAnimationCanvas.width = timerAnimationCanvas.parentElement.clientWidth;
                timerAnimationCanvas.height = timerAnimationCanvas.parentElement.clientHeight;
            }
            if (schmittTriggerAnimationCanvas) {
                schmittTriggerAnimationCtx = schmittTriggerAnimationCanvas.getContext('2d');
                schmittTriggerAnimationCanvas.width = schmittTriggerAnimationCanvas.parentElement.clientWidth;
                schmittTriggerAnimationCanvas.height = schmittTriggerAnimationCanvas.parentElement.clientHeight;
            }
        }

        function startHeartAnimations() {
            setupHeartCanvases(); // 캔버스 초기화
            if (window.timerAnimationId === null) { // window 객체를 통해 접근
                animationTime = 0; // 애니메이션 시간 초기화
                animateHeartWaves();
            }
            // OP-AMP 애니메이션 시작 (기존 텍스트 애니메이션)
            const opampAnimation = document.getElementById('opampAnimation');
            if (opampAnimation) {
                let lm386SignalSize = 10;
                opampAnimation.animationInterval = setInterval(() => {
                    lm386SignalSize = lm386SignalSize === 10 ? 20 : 10;
                    opampAnimation.innerHTML = `신호 증폭 중... <span style="font-size:${lm386SignalSize}px">🔊</span>`;
                }, 750);
            }
        }

        function stopHeartAnimations() {
            if (window.timerAnimationId) { // window 객체를 통해 접근
                cancelAnimationFrame(window.timerAnimationId); // window 객체를 통해 접근
                window.timerAnimationId = null; // window 객체에 할당
            }
            // OP-AMP 애니메이션 중지
            const opampAnimation = document.getElementById('opampAnimation');
            if (opampAnimation && opampAnimation.animationInterval) {
                clearInterval(opampAnimation.animationInterval);
                opampAnimation.innerHTML = `신호 증폭 중... (볼륨 업!)`; // 초기 텍스트로 되돌리기
                opampAnimation.animationInterval = null;
            }
        }


        // 기존 window.onload 내용
        window.addEventListener('load', () => {
            setupWaveCanvas();
            setupSynthCanvas();
            setupHandsPulseWidthCanvas(); // Hands section pulse width canvas setup
            showSection('sound'); // 초기 섹션 설정

            // Heart 섹션의 텍스트 애니메이션은 이제 startHeartAnimations/stopHeartAnimations에서 관리
            // 여기서는 초기 설정만 남겨둠
        });


        const potentiometerDemo = document.getElementById('potentiometerDemo');
        const potentiometerValue = document.getElementById('potentiometerValue');
        potentiometerDemo.addEventListener('input', (event) => {
            potentiometerValue.textContent = event.target.value;
            if (isTactOn) { // 택트 스위치가 켜져 있을 때만 소리 주파수 변경
                const val = parseInt(event.target.value);
                const audioFreq = 200 + (val / 100) * 1000; // 200Hz ~ 1200Hz 범위
                if (oscillator) {
                    // frequency가 유효한 숫자인지 확인
                    if (isFinite(audioFreq)) {
                        // hands 섹션의 택트 스위치 데모에서는 펄스 폭 조절을 사각파에만 적용
                        const demoWaveformType = 'square'; // hands 섹션 데모는 사각파로 고정
                        playTone(audioFreq, 0, handsCurrentPulseWidth / 100); // Pass duty cycle
                    } else {
                        console.error("Invalid audioFreq value from potentiometer:", audioFreq);
                        stopTone();
                    }
                }
            }
        });


        const tactSwitchDemo = document.getElementById('tactSwitchDemo');
        const tactSwitchStatus = document.getElementById('tactSwitchStatus');
        let isTactOn = false; // 택트 스위치 상태
        
        function handleTactSwitch(on) {
            if (on && !isTactOn) {
                isTactOn = true;
                tactSwitchStatus.textContent = '스위치 상태: 켜짐 (소리 재생!)';
                tactSwitchDemo.classList.add('bg-red-500', 'hover:bg-red-600');
                tactSwitchDemo.classList.remove('bg-sky-500', 'hover:bg-sky-600');
                
                const potVal = parseInt(potentiometerDemo.value);
                const audioFreq = 200 + (potVal / 100) * 1000;
                // hands 섹션의 택트 스위치 데모는 사각파와 펄스 폭 조절을 사용
                const originalSelectedWaveformType = selectedWaveformType; // 원래 선택된 파형 타입 저장
                selectedWaveformType = 'square'; // 일시적으로 사각파로 설정하여 PeriodicWave 사용
                playTone(audioFreq, 0, handsCurrentPulseWidth / 100); // 소리 재생 (무한), handsCurrentPulseWidth 적용
                selectedWaveformType = originalSelectedWaveformType; // 원래 파형 타입 복원

            } else if (!on && isTactOn) {
                isTactOn = false;
                tactSwitchStatus.textContent = '스위치 상태: 꺼짐 (마우스 클릭 또는 스페이스바 키로 조작)';
                tactSwitchDemo.classList.remove('bg-red-500', 'hover:bg-red-600');
                tactSwitchDemo.classList.add('bg-sky-500', 'hover:bg-sky-600');
                stopTone(); // 소리 멈춤
            }
        }

        // 마우스 이벤트 (PC용)
        tactSwitchDemo.addEventListener('mousedown', (event) => {
            event.preventDefault(); // 기본 드래그/선택 방지
            handleTactSwitch(true);
        });
        tactSwitchDemo.addEventListener('mouseup', () => handleTactSwitch(false));
        tactSwitchDemo.addEventListener('mouseleave', () => {
            if (isTactOn) handleTactSwitch(false); // 마우스가 버튼을 벗어났을 때 소리 멈춤
        });

        // 터치 이벤트 (모바일용)
        tactSwitchDemo.addEventListener('touchstart', (event) => {
            event.preventDefault(); // 기본 텍스트 선택/줌 방지
            handleTactSwitch(true);
        }, { passive: false }); // passive: false를 통해 preventDefault()가 작동하도록 함
        tactSwitchDemo.addEventListener('touchend', () => handleTactSwitch(false));


        // 키보드 이벤트 (스페이스바/엔터)
        let isSpaceOrEnterPressed = false; // 키 눌림 상태 추적
        document.addEventListener('keydown', (event) => {
            // 현재 섹션이 'hands'이고 스페이스바 또는 엔터 키가 눌렸으며, 이전에 눌리지 않았다면
            if (currentActiveSectionId === 'hands' && (event.key === ' ' || event.key === 'Enter') && !isSpaceOrEnterPressed) {
                event.preventDefault(); // 기본 동작 방지 (예: 스페이스바 스크롤)
                isSpaceOrEnterPressed = true;
                handleTactSwitch(true);
            }
        });

        document.addEventListener('keyup', (event) => {
            // 현재 섹션이 'hands'이고 스페이스바 또는 엔터 키가 떼졌으며, 이전에 눌린 상태였다면
            if (currentActiveSectionId === 'hands' && (event.key === ' ' || event.key === 'Enter') && isSpaceOrEnterPressed) {
                isSpaceOrEnterPressed = false;
                handleTactSwitch(false);
            }
        });


        let synthPitchKnob = document.getElementById('synthPitchKnob');
        let synthPitchValue = document.getElementById('synthPitchValue');
        const synthButtons = document.querySelectorAll('.synth-button');
        let synthOutputStatus = document.getElementById('synthOutputStatus');
        // synthOutputCanvas와 synthCtx를 let으로 변경하여 재할당 가능하도록 함
        let synthOutputCanvas; 
        let synthCtx;    

        // Pulse Width Control elements for 'play' section
        const pulseWidthControl = document.getElementById('pulseWidthControl');
        const pulseWidthKnob = document.getElementById('pulseWidthKnob');
        const pulseWidthValue = document.getElementById('pulseWidthValue');
        let currentPulseWidth = 50; // Default 50% duty cycle for 'play' section

        // Pulse Width Control elements for 'hands' section
        let handsPulseWidthKnob; // Defined globally now
        let handsPulseWidthValue; // Defined globally now
        let handsPulseWidthCanvas; // Defined globally now
        let handsPulseWidthCtx; // Defined globally now
        let handsCurrentPulseWidth = 50; // Default 50% duty cycle for 'hands' section

        // 섹션 4의 파형 시각화 함수
        function drawSynthWave(frequency, type, dutyCycle = 50) {
            // 캔버스 컨텍스트가 준비되지 않았다면 함수 종료
            if (!synthCtx || !synthOutputCanvas) return; 

            const width = synthOutputCanvas.width;
            const height = synthOutputCanvas.height;
            const amplitude = height / 3;
            const centerY = height / 2;
            
            synthCtx.clearRect(0, 0, width, height); // 캔버스 지우기
            synthCtx.beginPath(); // 새로운 경로 시작
            synthCtx.moveTo(0, centerY); // 시작점 설정

            // 선택된 파형 타입에 따라 다른 파형을 그림
            const visualCycles = frequency / 100; // 시각적 주파수 스케일 (적절히 조절)
            const period = width / visualCycles; // 한 주기(cycle)의 픽셀 길이
            const onWidth = period * (dutyCycle / 100); // ON 구간의 픽셀 길이

            for (let x = 0; x < width; x++) {
                let y;
                const angle = (x / width) * Math.PI * 2 * visualCycles; // 0에서 2*PI*cycles까지 변화

                switch (type) { // 전달받은 type 사용
                    case 'sine':
                        y = centerY + amplitude * Math.sin(angle);
                        break;
                    case 'square':
                        // 펄스 폭을 반영한 사각파 그리기
                        const phaseInPeriod = (x % period);
                        if (phaseInPeriod < onWidth) {
                            y = centerY - amplitude; // High
                        } else {
                            y = centerY + amplitude; // Low
                        }
                        break;
                    case 'sawtooth':
                        y = centerY - amplitude * (angle % (2 * Math.PI) / (2 * Math.PI) * 2 - 1);
                        break;
                    case 'triangle':
                        const phase = angle % (2 * Math.PI);
                        if (phase < Math.PI) {
                            y = centerY - amplitude * (1 - (phase / Math.PI) * 2);
                        } else {
                            y = centerY - amplitude * (-1 + ((phase - Math.PI) / Math.PI) * 2);
                        }
                        break;
                    default:
                        y = centerY + amplitude * Math.sin(angle); // 기본은 사인파
                }
                synthCtx.lineTo(x, y);
            }
            synthCtx.strokeStyle = 'rgb(16, 185, 129)'; // 초록색 선
            synthCtx.lineWidth = 2; // 선 두께
            synthCtx.stroke(); // 선 그리기
        }

        function setupSynthCanvas() {
            synthOutputCanvas = document.getElementById('synthOutputCanvas'); 
            if (synthOutputCanvas) { 
                synthCtx = synthOutputCanvas.getContext('2d'); 
                const container = synthOutputCanvas.parentElement;
                synthOutputCanvas.width = container.clientWidth;
                synthOutputCanvas.height = container.clientHeight;
                drawSynthWave(0, selectedWaveformType, currentPulseWidth); // 초기 파형 그리기 (소리 없음)
            }
        }

        // 'hands' 섹션의 펄스 폭 시각화 함수
        function drawHandsPulseWave(dutyCycle) {
            if (!handsPulseWidthCtx || !handsPulseWidthCanvas) return;

            const width = handsPulseWidthCanvas.width;
            const height = handsPulseWidthCanvas.height;
            const amplitude = height / 3;
            const centerY = height / 2;
            
            handsPulseWidthCtx.clearRect(0, 0, width, height);
            handsPulseWidthCtx.beginPath();
            handsPulseWidthCtx.moveTo(0, centerY);

            const visualCycles = 2; // Fixed number of cycles for this demo
            const period = width / visualCycles;
            const onWidth = period * (dutyCycle / 100);

            for (let x = 0; x < width; x++) {
                const phaseInPeriod = (x % period);
                let y;
                if (phaseInPeriod < onWidth) {
                    y = centerY - amplitude; // High
                } else {
                    y = centerY + amplitude; // Low
                }
                handsPulseWidthCtx.lineTo(x, y);
            }
            handsPulseWidthCtx.strokeStyle = 'rgb(124, 58, 237)'; // Purple color
            handsPulseWidthCtx.lineWidth = 2;
            handsPulseWidthCtx.stroke();
        }

        function setupHandsPulseWidthCanvas() {
            handsPulseWidthCanvas = document.getElementById('handsPulseWidthCanvas');
            if (handsPulseWidthCanvas) {
                handsPulseWidthCtx = handsPulseWidthCanvas.getContext('2d');
                const container = handsPulseWidthCanvas.parentElement;
                handsPulseWidthCanvas.width = container.clientWidth;
                handsPulseWidthCanvas.height = container.clientHeight;
                drawHandsPulseWave(handsCurrentPulseWidth);
            }
        }


        // 음계별 주파수 정의 (C4 기준)
        const noteFrequencies = {
            'C5': 523.25, // 도2
            'D5': 587.33, // 레2
            'E5': 659.25, // 미2
            'F5': 698.46, // 파2
            'G5': 783.99, // 솔2
            'A5': 880.00, // 라2
            'B5': 987.77,  // 시2
            'C4': 261.63, // 도1
            'D4': 293.66, // 레1
            'E4': 329.63, // 미1
            'F4': 349.23, // 파1
            'G4': 392.00, // 솔1
            'A4': 440.00, // 라1 (기준음)
            'B4': 493.88  // 시1
        };

        // 섹션 4: 음높이 조절 슬라이더의 input 이벤트 리스너 수정
        synthPitchKnob.addEventListener('input', (event) => {
            const pitch = parseInt(event.target.value);
            synthPitchValue.textContent = pitch;

            // 현재 오실레이터가 활성화되어 소리가 재생 중이라면 주파수 업데이트
            if (oscillator && currentPlayingBaseFreq !== 0) {
                const pitchMultiplier = 0.5 + (pitch / 100) * 1.5; // 피치 조절 범위 (0.5배 ~ 2배)
                const finalFreq = currentPlayingBaseFreq * pitchMultiplier;
                // frequency가 유효한 숫자인지 다시 확인
                if (isFinite(finalFreq)) {
                    // playTone 호출 시 현재 펄스 폭 값 전달
                    playTone(finalFreq, 0, currentPulseWidth / 100);
                } else {
                    console.error("Calculated finalFreq is non-finite:", finalFreq);
                    stopTone(); // 유효하지 않으면 소리 중단
                    return;
                }
                
                // 상태 텍스트 및 파형도 업데이트
                const activeNoteButton = document.querySelector('.synth-button.ring-4');
                if (activeNoteButton) {
                    const noteFull = activeNoteButton.dataset.noteFull; // 'C4', 'D4' 등
                    const noteName = noteFull.slice(0, -1);
                    const octave = parseInt(noteFull.slice(-1));
                    
                    // Hz 기반 표기를 위한 매핑
                    const noteTextMap = {
                        'C': '도', 'D': '레', 'E': '미', 'F': '파', 'G': '솔', 'A': '라', 'B': '시'
                    };
                    const displayNote = `${noteTextMap[noteName]}${octave - 3}`; // C4->도1, C5->도2
                    synthOutputStatus.textContent = `${displayNote} 음 (${selectedWaveformType}파) 재생! (주파수: ${finalFreq.toFixed(2)} Hz)`; // 파형 타입 추가
                    drawSynthWave(finalFreq, selectedWaveformType, currentPulseWidth); // 파형 타입과 듀티 사이클 전달
                }
            }
        });

        // 파형 선택 라디오 버튼 이벤트 리스너
        document.querySelectorAll('input[name="waveformType"]').forEach(radio => {
            radio.addEventListener('change', (event) => {
                selectedWaveformType = event.target.value;

                // 사각파 선택 시 펄스 폭 조절 슬라이더 표시/숨김
                if (selectedWaveformType === 'square') {
                    pulseWidthControl.classList.remove('hidden');
                } else {
                    pulseWidthControl.classList.add('hidden');
                }

                // 만약 현재 소리가 재생 중이라면 파형 타입 즉시 변경
                if (oscillator && currentPlayingBaseFreq !== 0) {
                    const pitch = parseInt(synthPitchKnob.value);
                    const finalFreq = currentPlayingBaseFreq * (0.5 + (pitch / 100) * 1.5);

                    // Re-initialize oscillator with new type/periodic wave
                    // playTone 호출 시 현재 펄스 폭 값 전달
                    playTone(finalFreq, 0, currentPulseWidth / 100); // Replay with new type and current duty cycle
                } else {
                    // If no sound is playing, just update the visual representation for the selected waveform
                    if (currentActiveSectionId === 'play') { // 'play' 섹션에 있을 때만 파형 시각화 업데이트
                        drawSynthWave(0, selectedWaveformType, currentPulseWidth);
                    }
                }
            });
        });

        // Pulse Width Slider Event Listener for 'play' section
        pulseWidthKnob.addEventListener('input', (event) => {
            currentPulseWidth = parseInt(event.target.value);
            pulseWidthValue.textContent = currentPulseWidth;

            // 소리가 재생 중이라면 파형만 업데이트
            if (oscillator && currentPlayingBaseFreq !== 0) {
                const pitch = parseInt(synthPitchKnob.value);
                const finalFreq = currentPlayingBaseFreq * (0.5 + (pitch / 100) * 1.5);
                drawSynthWave(finalFreq, selectedWaveformType, currentPulseWidth);
                // 사각파인 경우에만 오디오 업데이트
                if (selectedWaveformType === 'square') {
                    playTone(finalFreq, 0, currentPulseWidth / 100);
                }
            } else {
                // 소리가 재생 중이 아니라면, 현재 선택된 파형 타입이 사각파일 경우에만 파형 업데이트
                if (selectedWaveformType === 'square' && currentActiveSectionId === 'play') {
                     drawSynthWave(0, selectedWaveformType, currentPulseWidth); // 주파수 0으로 파형만 그림
                }
            }
        });

        // Pulse Width Slider Event Listener for 'hands' section
        // Note: handsPulseWidthKnob, handsPulseWidthValue, handsPulseWidthCanvas, handsPulseWidthCtx are defined globally above
        handsPulseWidthKnob = document.getElementById('handsPulseWidthKnob');
        handsPulseWidthValue = document.getElementById('handsPulseWidthValue');
        handsPulseWidthCanvas = document.getElementById('handsPulseWidthCanvas');
        handsPulseWidthCtx = handsPulseWidthCanvas.getContext('2d');

        if (handsPulseWidthKnob) {
            handsPulseWidthKnob.addEventListener('input', (event) => {
                handsCurrentPulseWidth = parseInt(event.target.value);
                handsPulseWidthValue.textContent = handsCurrentPulseWidth;
                drawHandsPulseWave(handsCurrentPulseWidth);

                // If tact switch is on, update audio with new pulse width
                if (isTactOn) {
                    const potVal = parseInt(potentiometerDemo.value);
                    const audioFreq = 200 + (potVal / 100) * 1000;
                    const originalSelectedWaveformType = selectedWaveformType; // 원래 선택된 파형 타입 저장
                    selectedWaveformType = 'square'; // 일시적으로 사각파로 설정하여 PeriodicWave 사용
                    playTone(audioFreq, 0, handsCurrentPulseWidth / 100);
                    selectedWaveformType = originalSelectedWaveformType; // 원래 파형 타입 복원
                }
            });
        }

        // 음계별 HSL 색조 값 (Hue)
        const noteHueMap = {
            'C': 0,    // 빨강
            'D': 30,   // 주황
            'E': 60,   // 노랑
            'F': 120,  // 초록
            'G': 240,  // 파랑
            'A': 270,  // 남색 (보라에 가까움)
            'B': 300   // 보라
        };

        // 옥타브별 밝기 (Lightness) 값
        const octaveLightness = {
            '5': 80, // 높은 옥타브 (밝게)
            '4': 60  // 낮은 옥타브 (진하게)
        };

        // 채도 (Saturation)는 고정값으로 설정
        const fixedSaturation = 80; // %

        function getNoteGradient(noteFull) {
            const noteName = noteFull.slice(0, -1); // 'C', 'D' 등
            const octave = noteFull.slice(-1);    // '4', '5'

            const hue = noteHueMap[noteName] || 0; // 기본값 0 (빨강)
            const lightness = octaveLightness[octave] || 70; // 기본값 70 (중간 밝기)

            // 그라데이션을 위해 시작 색상과 끝 색상 정의
            const startColor = `hsl(${hue}, ${fixedSaturation}%, ${lightness}%)`;
            const endColor = `hsl(${hue}, ${fixedSaturation}%, ${lightness - 20}%)`; // 시작보다 20% 어둡게

            return `linear-gradient(to bottom, ${startColor}, ${endColor})`;
        }

        // 건반 버튼에 색상 적용
        synthButtons.forEach(button => {
            const noteFull = button.dataset.noteFull;
            button.style.background = getNoteGradient(noteFull);

            // 마우스 이벤트 (PC용)
            button.addEventListener('mousedown', (event) => {
                event.preventDefault(); // 기본 드래그/선택 방지
                const noteFull = button.dataset.noteFull; // 'C4', 'D4' 등
                const pitch = parseInt(synthPitchKnob.value);
                
                let baseFreq = noteFrequencies[noteFull];
                currentPlayingBaseFreq = baseFreq; // 현재 재생 중인 음의 기본 주파수 저장

                const pitchMultiplier = 0.5 + (pitch / 100) * 1.5; // 피치 조절 범위 (0.5배 ~ 2배)
                const finalFreq = baseFreq * pitchMultiplier;

                const noteName = noteFull.slice(0, -1);
                const octave = parseInt(noteFull.slice(-1));
                const noteTextMap = {
                    'C': '도', 'D': '레', 'E': '미', 'F': '파', 'G': '솔', 'A': '라', 'B': '시'
                };
                const displayNote = `${noteTextMap[noteName]}${octave - 3}`; // C4->도1, C5->도2

                synthOutputStatus.textContent = `${displayNote} 음 (${selectedWaveformType}파) 재생! (주파수: ${finalFreq.toFixed(2)} Hz)`; // 파형 타입 추가
                
                playTone(finalFreq, 0, currentPulseWidth / 100); // 펄스 폭 전달
                drawSynthWave(finalFreq, selectedWaveformType, currentPulseWidth); // 소리 재생 시 파형 그림
                button.classList.add('ring-4', 'ring-yellow-300'); // 버튼에 테두리 효과
            });
            button.addEventListener('mouseup', () => {
                synthOutputStatus.textContent = '대기 중...';
                drawSynthWave(0, selectedWaveformType, currentPulseWidth); // 소리 멈춤 시 파형 초기화
                button.classList.remove('ring-4', 'ring-yellow-300'); // 테두리 효과 제거
                stopTone();
                currentPlayingBaseFreq = 0; // 재생 멈추면 기본 주파수 초기화
            });
            button.addEventListener('mouseleave', () => {
                 // 마우스가 버튼을 벗어났을 때, 해당 버튼이 활성화 상태였다면 소리 멈춤
                 if (button.classList.contains('ring-4')) {
                    synthOutputStatus.textContent = '대기 중...';
                    drawSynthWave(0, selectedWaveformType, currentPulseWidth);
                    button.classList.remove('ring-4', 'ring-yellow-300');
                    stopTone();
                    currentPlayingBaseFreq = 0;
                 }
            });

            // 터치 이벤트 (모바일용)
            button.addEventListener('touchstart', (event) => {
                event.preventDefault(); // 기본 텍스트 선택/줌 방지
                const noteFull = button.dataset.noteFull;
                const pitch = parseInt(synthPitchKnob.value);
                
                let baseFreq = noteFrequencies[noteFull];
                currentPlayingBaseFreq = baseFreq; // 현재 재생 중인 음의 기본 주파수 저장

                const pitchMultiplier = 0.5 + (pitch / 100) * 1.5;
                const finalFreq = baseFreq * pitchMultiplier;

                synthOutputStatus.textContent = `${noteFull} 음 (${selectedWaveformType}파) 재생! (주파수: ${finalFreq.toFixed(2)} Hz)`; // 파형 타입 추가
                
                playTone(finalFreq, 0, currentPulseWidth / 100); // 펄스 폭 전달
                drawSynthWave(finalFreq, selectedWaveformType, currentPulseWidth);
                button.classList.add('ring-4', 'ring-yellow-300');
            }, { passive: false }); // passive: false를 통해 preventDefault()가 작동하도록 함

            button.addEventListener('touchend', () => {
                synthOutputStatus.textContent = '대기 중...';
                drawSynthWave(0, selectedWaveformType, currentPulseWidth);
                button.classList.remove('ring-4', 'ring-yellow-300');
                stopTone();
                currentPlayingBaseFreq = 0; // 재생 멈추면 기본 주파수 초기화
            });
        });
        
        // 윈도우 크기 변경 시 캔버스 크기 재설정
        window.addEventListener('resize', () => {
            setupWaveCanvas();
            setupSynthCanvas();
            // Heart 섹션의 캔버스도 리사이즈 시 재설정
            setupHeartCanvases();
            setupHandsPulseWidthCanvas(); // Hands section pulse width canvas setup on resize
        });

    </script>
</body>
</html>
