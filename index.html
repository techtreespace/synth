<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DIY 아날로그 신디사이저 탐험</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f0f0; /* Light gray background */
            /* 모바일 텍스트 크기 조정을 위한 기본 폰트 크기 설정 */
            @apply text-base sm:text-lg;
        }
        .tab-button {
            @apply px-4 py-2 font-semibold rounded-t-lg transition-colors duration-200 ease-in-out;
        }
        .tab-button.active {
            @apply bg-sky-600 text-white;
        }
        .tab-button:not(.active) {
            @apply text-sky-700 bg-sky-100 hover:bg-sky-200;
        }
        .content-section {
            /* 기존 min-h-[400px] 제거, flex-grow와 overflow-y-auto 추가 */
            @apply p-6 bg-white rounded-b-lg rounded-tr-lg shadow-lg flex-grow overflow-y-auto flex flex-col;
        }
        .interactive-box {
            @apply border-2 border-dashed border-amber-500 p-4 rounded-lg mt-4 text-center;
        }
        .component-card {
            @apply bg-stone-100 p-4 rounded-lg shadow hover:shadow-md transition-shadow;
        }
        .chart-container {
            position: relative;
            width: 100%;
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
            height: 200px;
            max-height: 250px;
            background-color: #f0f0f0;
            border-radius: 0.5rem;
        }
        @media (min-width: 768px) {
            .chart-container {
                height: 250px;
            }
        }
        /* 추가된 CSS: 텍스트 선택 방지 */
        .synth-button, #tactSwitchDemo {
            -webkit-user-select: none; /* Safari */
            -ms-user-select: none; /* IE 10+ */
            user-select: none; /* Standard syntax */
            touch-action: manipulation; /* 터치 이벤트 최적화: 탭 지연 제거 및 확대/확대 방지 */
        }
        /* 건반 버튼 크기 고정 및 내용 중앙 정렬 - 수정됨 */
        .synth-button {
            /* 모바일 기본 크기를 2배 키움*/
            @apply min-w-[8rem] h-32 text-3xl
                   sm:min-w-[9rem] sm:h-36 sm:text-4xl
                   md:min-w-[10rem] md:h-40 md:text-5xl
                   lg:min-w-[12rem] lg:h-48 lg:text-6xl
                   flex items-center justify-center text-white font-bold;
            flex-shrink: 0;
            background-image: linear-gradient(to bottom, #d1d5db, #6b7280);
        }
        /* Heart section canvas styling */
        .heart-canvas-container {
            height: 100px; /* Fixed height for animation canvases */
            width: 100%;
            background-color: #e0f2fe; /* Light blue background for clarity */
            border-radius: 0.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden; /* Ensure waves don't overflow */
        }

        /* Mobile navigation overlay styles */
        .mobile-nav-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9); /* Semi-transparent black background */
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            transform: translateX(100%); /* Start off-screen to the right */
            transition: transform 0.3s ease-in-out; /* Smooth transition */
        }

        .mobile-nav-overlay.open {
            transform: translateX(0); /* Slide in */
        }

        .mobile-nav-overlay .close-btn {
            position: absolute;
            top: 1.5rem;
            right: 1.5rem;
            font-size: 2rem;
            cursor: pointer;
            color: white;
        }

        .mobile-nav-overlay .nav-links {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            width: 100%; /* Take full width */
            align-items: flex-start; /* Align items to the left */
            padding-left: 2rem; /* Add left padding */
        }

        .mobile-nav-overlay .nav-links .tab-button {
            @apply text-white text-2xl bg-transparent hover:bg-sky-700 rounded-lg py-3 px-6;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2); /* Add subtle separator */
            text-align: left; /* Ensure text is left-aligned */
            width: 100%; /* Ensure button takes full width of its container */
        }
        .mobile-nav-overlay .nav-links .tab-button:last-child {
            border-bottom: none;
        }

        /* Main Page Overlay styles */
        #main-page-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #1e3a8a; /* Dark blue background */
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 2rem; /* Default padding for all screens */
            text-align: center;
            z-index: 2000; /* Ensure it's on top of everything */
            transition: opacity 0.5s ease-in-out;
            opacity: 1;
            visibility: visible;
            /* Added for better mobile spacing */
            @apply px-4 sm:px-8 md:px-16; /* More responsive horizontal padding */
        }
        #main-page-overlay.hidden {
            opacity: 0;
            visibility: hidden;
            pointer-events: none; /* Prevent interaction when hidden */
        }
        #main-page-overlay h2 { /* Changed to be smaller, for "Welcome to" */
            @apply text-4xl sm:text-5xl font-extrabold mb-4 leading-tight; /* Increased font size */
        }
        #main-page-overlay h1 { /* New style for "DIY Analog Synthesizer" */
            @apply text-6xl sm:text-7xl md:text-8xl font-extrabold mb-8 leading-tight; /* Increased font size */
        }
        #main-page-overlay button {
            /* Changed to white background, text color matching overlay background */
            @apply bg-white hover:bg-gray-100 text-[#1e3a8a] text-2xl font-bold py-4 px-10 rounded-full shadow-xl transition-all duration-300 transform hover:scale-105 mt-8 border-2 border-[#1e3a8a];
        }
        /* Main page "Let's go!" button border */
        #main-page-overlay #start-exploration-button {
            border: 2px solid white; /* White border */
        }
        /* Removed Main page image styling */
        /* Removed Main page graphic element styling */
        /* New content box styling */
        #main-page-overlay .content-box {
            @apply bg-blue-800 p-6 rounded-lg shadow-xl max-w-3xl mx-auto text-white text-center; /* Changed text-left to text-center */
        }
        #main-page-overlay .content-box h3 { /* This was for "DIY 아날로그 신디사이저 프로젝트" - can be removed or repurposed */
            @apply text-2xl sm:text-3xl font-bold mb-4 text-center;
        }
        #main-page-overlay .content-box ul { /* This was for the bullet list - will be replaced by spans */
            @apply space-y-3 text-lg;
        }
        #main-page-overlay .content-box li { /* This was for list items - will be replaced by spans */
            @apply flex items-start;
        }
        #main-page-overlay .content-box li span:first-child { /* This was for icon styling - can be removed or repurposed */
            @apply text-amber-300 mr-3 text-xl sm:text-2xl;
        }
        /* 슬라이드 컨테이너 스타일 */
        .slide-container {
            position: relative;
            width: 100%;
            height: 500px; /* 슬라이드 높이 고정 */
            overflow: hidden;
            margin-top: 2rem;
            border-radius: 0.5rem;
            background-color: #f0f0f0;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            /* flexbox를 사용하여 iframe을 중앙에 정렬하고, 필요한 경우만 스크롤바 표시 */
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: auto; /* 내용이 넘칠 경우 스크롤 허용 */
        }

        /* 각 슬라이드 페이지 스타일 - 이제 사용되지 않음 */
        /*
        .slide-page {
            min-width: 100%;
            transition: transform 0.5s ease-in-out;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 1.5rem;
            box-sizing: border-box;
            font-size: 1.1rem;
            color: #333;
            background-color: #fff;
        }
        .slide-page img {
            max-width: 90%;
            max-height: 80%;
            object-fit: contain;
            border-radius: 0.5rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            margin-bottom: 1rem;
        }
        */

        /* 슬라이드 네비게이션 버튼 및 인디케이터는 이제 사용되지 않음 */
        /*
        .slide-nav-button {
            @apply absolute top-1/2 -translate-y-1/2 px-4 py-2 bg-sky-600 text-white rounded-full shadow-lg hover:bg-sky-700 transition-colors z-10;
        }
        .slide-nav-button.left {
            left: 1rem;
        }
        .slide-nav-button.right {
            right: 1rem;
        }
        .slide-indicators {
            @apply flex justify-center mt-4 space-x-2;
        }
        .slide-indicator-dot {
            @apply w-3 h-3 bg-gray-300 rounded-full cursor-pointer;
        }
        .slide-indicator-dot.active {
            @apply bg-sky-600;
        }
        */
    </style>
</head>
<body class="flex flex-col min-h-screen bg-amber-50 text-stone-800 overflow-x-hidden">
    <div id="main-page-overlay">
        <h2 class="text-amber-300">Welcome to</h2>
        <h1 class="text-white">DIY Analog Synthesizer</h1>

        <div class="w-full max-w-md my-8 border-t-2 border-dashed border-white"></div>

        <div class="content-box">
            <div class="flex flex-wrap justify-center gap-2 mb-4">
                <span class="bg-blue-600 text-white px-3 py-1 rounded-full text-sm sm:text-base">#아날로그전자부품</span>
                <span class="bg-blue-600 text-white px-3 py-1 rounded-full text-sm sm:text-base">#소리합성변형</span>
                <span class="bg-blue-600 text-white px-3 py-1 rounded-full text-sm sm:text-base">#따뜻하고풍부한음색</span>
                <span class="bg-blue-600 text-white px-3 py-1 rounded-full text-sm sm:text-base">#악기</span>
            </div>
            <p class="text-xl sm:text-2xl font-semibold text-center text-white mb-6">재미있게 탐험해 볼까요?</p>
        </div>

        <button id="start-exploration-button">
            Let's go !
        </button>
    </div>

    <header class="flex-shrink-0 bg-sky-700 text-white p-6 shadow-md sticky top-0 z-50 transition-transform duration-300 ease-in-out">
        <div class="container mx-auto flex flex-col sm:flex-row justify-between items-center">
            <div class="flex justify-between items-center w-full sm:w-auto">
                <h1 class="text-xl sm:text-2xl md:text-3xl font-bold text-white text-center sm:text-left mb-0 sm:mb-0">DIY 아날로그 신디사이저 탐험</h1>
                <button id="mobile-menu-toggle" class="sm:hidden text-white text-2xl focus:outline-none ml-4">
                    <i class="fas fa-bars"></i>
                </button>
            </div>
            
            <nav class="hidden sm:flex mt-4 sm:mt-0 space-x-4">
                <button class="tab-button active" onclick="showSection('sound')">1. 소리의 세계</button>
                <button class="tab-button" onclick="showSection('heart')">2. 신디사이저의 기본 구조</button>
                <button class="tab-button" onclick="showSection('hands')">3. 신디사이저 조작 및 음색 조절</button>
                <button class="tab-button" onclick="showSection('play')">4. 신디사이저 연주 체험</button>
                <button class="tab-button" onclick="showSection('summary')">5. 핵심 정리와 다음 단계</button>
            </nav>
        </div>
    </header>

    <div id="mobile-nav-overlay" class="mobile-nav-overlay">
        <button id="close-mobile-menu" class="close-btn">
            <i class="fas fa-times"></i>
        </button>
        <div class="nav-links">
            <button class="tab-button" onclick="showSection('sound')">1. 소리의 세계</button>
            <button class="tab-button" onclick="showSection('heart')">2. 신디사이저의 기본 구조</l>
            <button class="tab-button" onclick="showSection('hands')">3. 신디사이저 조작 및 음색 조절</button>
            <button class="tab-button" onclick="showSection('play')">4. 신디사이저 연주 체험</button>
            <button class="tab-button" onclick="showSection('summary')">5. 핵심 정리와 다음 단계</button>
        </div>
    </div>

    <main class="flex-grow container mx-auto px-4 sm:px-8 lg:px-16 max-w-7xl flex flex-col overflow-hidden">
        <div id="sound" class="content-section">
            <h2 class="text-2xl font-bold text-sky-700 mb-4">1. 소리의 세계 🌍</h2>
            <p class="mb-4">이 섹션에서는 우리 주변의 '소리'가 무엇인지, 어떻게 만들어지고 우리가 어떻게 듣게 되는지 기본적인 원리를 탐험합니다. 신디사이저를 이해하기 위한 첫걸음, 시작해볼까요?</p>
            
            <div class="grid md:grid-cols-2 gap-6">
                <div class="component-card">
                    <h3 class="text-xl font-semibold text-emerald-700 mb-2">소리의 발생 원리</h3>
                    <p>소리는 물체가 <strong class="text-amber-600">진동</strong>해서 만들어지는 에너지의 한 형태예요. 기타 줄을 튕기면 줄이 떨리죠? 이 떨림(진동)이 공기를 흔들어 우리 귀에 닿으면 소리로 인식된답니다. 마치 물 위에 돌을 던졌을 때 물결이 퍼져나가는 것과 비슷해요!</p>
                </div>
                <div class="component-card">
                    <h3 class="text-xl font-semibold text-emerald-700 mb-2">소리의 높낮이 (음고)</h3>
                    <p>소리의 높낮이는 진동이 얼마나 <strong class="text-amber-600">빠르게</strong> 일어나는지에 따라 결정돼요. 진동이 빠르면 높은 소리(고음), 느리면 낮은 소리(저음)가 나죠. 1초에 몇 번 진동하는지를 나타내는 단위를 <strong class="text-amber-600">주파수(Hz)</strong>라고 해요. 주파수가 높을수록 높은 소리가 납니다!</p>
                </div>
            </div>

<div class="interactive-box mt-6">
    <h4 class="text-lg font-semibold mb-2">주파수 조절 체험</h4>
    
    <div class="flex flex-col md:flex-row items-center justify-center gap-4">
        <div class="chart-container mt-4 md:mt-0 w-full md:w-1/2">
            <canvas id="waveCanvas"></canvas>
        </div>
        
        <div class="w-full md:w-1/2 flex flex-col items-center">
            <p class="mb-2 text-sm text-center">아래 슬라이더를 움직여 주파수를 조절해보세요.<br> 주파수에 따라 파형이 어떻게 변하고 소리가 어떻게 달라지는지 관찰해봅시다!</p>
            <input type="range" id="frequencySlider" min="1" max="20" value="5" class="w-full max-w-md mx-auto accent-amber-500">
            <p class="mt-2">현재 주파수 단계: <span id="frequencyValue" class="font-bold text-sky-600">5</span></p>
            <p id="pitchDescription" class="mt-2 font-semibold h-6"></p> </div>
    </div>
</div>
        </div>

        <div id="heart" class="content-section hidden">
            <h2 class="text-2xl font-bold text-sky-700 mb-4">2. 신디사이저의 기본 구조</h2>
            <p class="mb-4">아날로그 신디사이저는 크게 <strong class="text-amber-600">발진기(오실레이터)</strong>, <strong class="text-amber-600">필터</strong>, <strong class="text-amber-600">앰프</strong> 등으로 구성되어 있어요. 그 중에서도 오실레이터는 다양한 파형의 전기 신호를 만들어내는 핵심 부품입니다.</p>
            
            <div class="grid md:grid-cols-3 gap-6 mb-6">
                <div class="component-card">
                    <h3 class="text-xl font-semibold text-emerald-700 mb-2">오실레이터 (Oscillator)</h3>
                    <p>사각파, 삼각파, 톱니파 등 다양한 파형의 전기 신호를 만들어내는 역할을 합니다. 신디사이저 소리의 <strong class="text-amber-600">기본적인 음색과 높낮이</strong>를 결정해요.</p>
                </div>
                <div class="component-card">
                    <h3 class="text-xl font-semibold text-emerald-700 mb-2">필터 (Filter)</h3>
                    <p>만들어진 소리의 특정 주파수 영역을 <strong class="text-amber-600">강조하거나 약화</strong>시켜 음색을 바꿔주는 역할을 해요. 탁한 소리를 맑게 하거나, 날카로운 소리를 부드럽게 만들 수 있습니다.</p>
                </div>
                <div class="component-card">
                    <h3 class="text-xl font-semibold text-emerald-700 mb-2">앰프 (Amplifier)</h3>
                    <p>오실레이터와 필터를 거쳐 만들어진 소리 신호는 매우 작아요. 앰프는 이 신호의 <strong class="text-amber-600">크기를 조절</strong>하여 우리가 들을 수 있는 충분한 볼륨으로 키워줍니다.</p>
                </div>
            </div>

            <h3 class="text-xl font-bold text-sky-700 mb-4">우리가 만들 신디사이저에 사용되는 부품들</h3>
            <div class="grid md:grid-cols-2 gap-6">
                <div class="col-span-1">
                    <h4 class="text-lg font-semibold text-emerald-600 mb-2">발진기(오실레이터) 관련 부품</h4>
                    <div class="space-y-4"> <div class="component-card">
                            <h3 class="text-xl font-semibold text-emerald-700 mb-2">555 타이머: 발진기 핵심 부품</h3>
                            <p>우리가 만들 신디사이저의 <strong class="text-amber-600">오실레이터</strong>는 바로 이 555 타이머를 활용하여 구성됩니다. 555 타이머는 규칙적인 <strong class="text-amber-600">전기 신호(펄스)</strong>를 만들어내며, 이 펄스의 빠르기가 소리의 높낮이를 결정하는 핵심적인 역할을 합니다.</p>
                            <div class="heart-canvas-container mt-2">
                                <canvas id="timerAnimationCanvas"></canvas>
                            </div>
                        </div>
                        <div class="component-card">
                            <h3 class="text-xl font-semibold text-emerald-700 mb-2">슈미트 트리거: 파형 다듬기</h3>
                            <p>555 타이머가 생성한 신호를 더욱 깨끗하고 안정적인 <strong class="text-amber-600">사각파</strong> 형태로 다듬어주는 역할을 합니다. 슈미트 트리거는 특정 전압(임계값)을 기준으로 출력을 확실하게 전환시켜, 명확한 파형을 만들어 <strong class="text-amber-600">오실레이터</strong>의 중요한 부분이 됩니다.</p>
                            <div class="heart-canvas-container mt-2">
                                <canvas id="schmittTriggerAnimationCanvas"></canvas>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="col-span-1">
                    <h4 class="text-lg font-semibold text-emerald-600 mb-2">앰프 관련 부품</h4>
                    <div class="space-y-4">
                        <div class="component-card">
                            <h3 class="text-xl font-semibold text-emerald-700 mb-2">OP-AMP (연산 증폭기): 앰프 역할</h3>
                            <p>555 타이머와 슈미트 트리거를 통해 만들어진 소리 신호는 아직 매우 작습니다. <strong class="text-amber-600">앰프</strong> 역할을 하는 OP-AMP는 이 작은 신호를 크게 <strong class="text-amber-600">증폭</strong>시켜 우리가 스피커를 통해 들을 수 있도록 해줍니다.</p>
                            <div id="opampAnimation" class="mt-2 h-16 bg-emerald-100 rounded flex items-center justify-center text-sm text-emerald-700">
                                신호 증폭 중... (소리가 커집니다!)
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div id="hands" class="content-section hidden">
            <h2 class="text-2xl font-bold text-sky-700 mb-4">3. 신디사이저 조작 및 음색 조절: 주요 부품들 🖐️🦶</h2>
            <p class="mb-4">신디사이저를 직접 조작하고 소리를 다양하게 만들기 위해 전기 흐름을 조절하는 '저항', 소리 높낮이를 바꾸는 '가변저항', 소리를 켜고 끄는 '택트 스위치'에 대해 알아볼까요?</p>
            <div class="grid md:grid-cols-3 gap-6">
                <div class="component-card">
                    <h3 class="text-xl font-semibold text-emerald-700 mb-2">저항: 전기 흐름의 문지기</h3>
                    <p>저항은 전기 회로에서 전류의 양을 조절하거나 전압을 나누는 역할을 해요. 마치 수도꼭지로 물의 양을 조절하듯, 저항은 전기 에너지의 흐름을 <strong class="text-amber-600">적절하게 제어</strong>합니다. 555 타이머의 작동 속도 조절에도 관여해요.</p>
                </div>
                <div class="component-card">
                    <h3 class="text-xl font-semibold text-emerald-700 mb-2">가변저항: 소리 높낮이 마법사</h3>
                    <p>가변저항은 손잡이를 돌리거나 슬라이드를 움직여 저항값을 바꿀 수 있는 특별한 저항이에요. 신디사이저에서는 이 가변저항을 이용하여 555 타이머에 연결된 저항값을 변화시키고, 결과적으로 <strong class="text-amber-600">소리의 높낮이를 마음대로 조절</strong>할 수 있게 해줍니다. 라디오 볼륨 조절기처럼요!</p>
                     <div class="interactive-box mt-2">
                        <label for="potentiometerDemo" class="block text-sm font-medium text-gray-700">가변저항 체험: <span id="potentiometerValue" class="font-bold text-sky-600">50</span>%</label>
                        <input type="range" id="potentiometerDemo" min="0" max="100" value="50" class="w-full accent-amber-500 mt-1">
                    </div>
                    <p class="mt-2">또한, 사각파의 <strong class="text-amber-600">펄스 폭(Duty Cycle)</strong>은 파형이 '켜져 있는' 시간의 비율을 의미하며, 이는 소리의 <strong class="text-amber-600">음색(Timbre)</strong>을 변화시킵니다. 555 타이머와 같은 발진 회로에서는 저항값을 조절하여 이 펄스 폭을 변경할 수 있습니다.</p>
                     <div class="interactive-box mt-4">
                        <label for="handsPulseWidthKnob" class="block text-sm font-medium text-gray-700">
                            펄스 폭 조절 (Duty Cycle): <span id="handsPulseWidthValue" class="font-bold text-sky-600">50</span>%
                        </label>
                        <input type="range" id="handsPulseWidthKnob" min="10" max="90" value="50" class="w-full accent-purple-500 mt-1">
                        <canvas id="handsPulseWidthCanvas" class="mt-2 w-full h-16 rounded bg-amber-100"></canvas>
                    </div>
                </div>
                <div class="component-card">
                    <h3 class="text-xl font-semibold text-emerald-700 mb-2">택트 스위치: 소리 재생 버튼</h3>
                    <p>택트 스위치는 누르면 회로가 연결되어 소리가 나고, 손을 떼면 회로가 멈추는 <strong class="text-amber-600">버튼</strong>이에요. 전등 스위치처럼 전기의 길을 열었다 닫았다 하며 신디사이저 소리를 제어합니다.</p>
                    <div class="interactive-box mt-2">
                        <button id="tactSwitchDemo" class="bg-sky-500 hover:bg-sky-600 text-white font-bold py-2 px-4 rounded transition-colors">
                            스위치 누르기!
                        </button>
                        <p id="tactSwitchStatus" class="text-sm mt-1">스위치 상태: 꺼짐 (마우스 클릭 또는 스페이스바 키로 조작)</p>
                    </div>
                </div>
            </div>
        </div>

        <div id="play" class="content-section hidden">
            <h2 class="text-2xl font-bold text-sky-700 mb-4">4. 신디사이저 연주 체험: 소리를 직접 만들어보자! 🎹✨</h2>
            <p class="mb-4">지금까지 배운 내용을 바탕으로 신디사이저를 연주해봅시다! 가변저항으로 음높이를 조절하고, 택트 스위치로 소리를 내보세요.</p>
            
            <div class="bg-stone-200 p-4 rounded-lg shadow-inner max-w-2xl mx-auto flex flex-col flex-grow select-none">
                <h3 class="text-xl font-semibold text-center text-stone-700 mb-4">아날로그 신디사이저 시뮬레이터</h3>
                
                <div class="flex flex-col items-center space-y-4 flex-grow">
                    <div class="grid grid-cols-2 gap-4 mb-4 w-full justify-items-start sm:flex sm:flex-wrap sm:justify-center">
                        <label class="inline-flex items-center justify-start sm:justify-center">
                            <input type="radio" name="waveformType" value="sine" class="form-radio text-sky-600 accent-sky-600" checked>
                            <span class="ml-2 text-sm font-medium text-gray-700">사인파 (Sine)</span>
                        </label>
                        <label class="inline-flex items-center justify-start sm:justify-center">
                            <input type="radio" name="waveformType" value="square" class="form-radio text-sky-600 accent-sky-600">
                            <span class="ml-2 text-sm font-medium text-gray-700">사각파 (Square)</span>
                        </label>
                        <label class="inline-flex items-center justify-start sm:justify-center">
                            <input type="radio" name="waveformType" value="sawtooth" class="form-radio text-sky-600 accent-sky-600">
                            <span class="ml-2 text-sm font-medium text-gray-700">톱니파 (Sawtooth)</span>
                        </label>
                        <label class="inline-flex items-center justify-start sm:justify-center">
                            <input type="radio" name="waveformType" value="triangle" class="form-radio text-sky-600 accent-sky-600">
                            <span class="ml-2 text-sm font-medium text-gray-700">삼각파 (Triangle)</span>
                        </label>
                    </div>

                    <div class="flex flex-col md:flex-row items-center justify-center gap-4 w-full">
                        <div class="chart-container w-full md:w-1/2 h-48"> <canvas id="synthOutputCanvas"></canvas>
                        </div>
                        
                        <div class="w-full md:w-1/2 flex flex-col items-center space-y-4">
                            <div id="pulseWidthControl" class="w-full max-w-xs"> <label for="pulseWidthKnob" class="block text-sm font-medium text-gray-700 mb-1">펄스 폭 조절 (듀티 사이클): <span id="pulseWidthValue" class="font-bold">50</span>%</label>
                                <input type="range" id="pulseWidthKnob" min="10" max="90" value="50" class="w-full accent-purple-500">
                            </div>

                            <div class="w-full max-w-xs"> <label for="synthPitchKnob" class="block text-sm font-medium text-gray-700 mb-1">음높이 조절 (가변저항): <span id="synthPitchValue" class="font-bold">50</span></label>
                                <input type="range" id="synthPitchKnob" min="1" max="100" value="50" class="w-full accent-amber-500">
                            </div>
                        </div>
                    </div>
                    
                    <p id="synthOutputStatus" class="mt-2 text-center font-semibold text-stone-700 h-6">버튼을 눌러 연주해보세요!</p>

                    <div class="flex flex-col gap-4 w-full items-center">
                        <div class="flex flex-wrap justify-center gap-4 sm:gap-6 md:gap-8">
                            <button class="synth-button rounded-lg shadow transition-transform hover:scale-105" data-note-full="C5">도</button>
                            <button class="synth-button rounded-lg shadow transition-transform hover:scale-105" data-note-full="D5">레</button>
                            <button class="synth-button rounded-lg shadow transition-transform hover:scale-105" data-note-full="E5">미</button>
                            <button class="synth-button rounded-lg shadow transition-transform hover:scale-105" data-note-full="F5">파</button>
                            <button class="synth-button rounded-lg shadow transition-transform hover:scale-105" data-note-full="G5">솔</button>
                            <button class="synth-button rounded-lg shadow transition-transform hover:scale-105" data-note-full="A5">라</button>
                            <button class="synth-button rounded-lg shadow transition-transform hover:scale-105" data-note-full="B5">시</button>
                        </div>
                        <div class="flex flex-wrap justify-center gap-4 sm:gap-6 md:gap-8">
                            <button class="synth-button rounded-lg shadow transition-transform hover:scale-105" data-note-full="C4">도</button>
                            <button class="synth-button rounded-lg shadow transition-transform hover:scale-105" data-note-full="D4">레</button>
                            <button class="synth-button rounded-lg shadow transition-transform hover:scale-105" data-note-full="E4">미</button>
                            <button class="synth-button rounded-lg shadow transition-transform hover:scale-105" data-note-full="F4">파</button>
                            <button class="synth-button rounded-lg shadow transition-transform hover:scale-105" data-note-full="G4">솔</button>
                            <button class="synth-button rounded-lg shadow transition-transform hover:scale-105" data-note-full="A4">라</button>
                            <button class="synth-button rounded-lg shadow transition-transform hover:scale-105" data-note-full="B4">시</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div id="summary" class="content-section hidden">
            <h2 class="text-2xl font-bold text-sky-700 mb-4">5. 핵심 정리와 다음 단계 💡</h2>
            <p class="mb-4">오늘 우리는 소리의 신비로운 세계부터 신디사이저의 작동 원리까지 많은 것을 배웠어요. 이 섹션에서는 주요 내용을 다시 한번 정리하고, 앞으로 더 재미있게 전자공학을 탐구할 수 있는 몇 가지 팁을 알려줄게요!</p>
            
            <div class="space-y-4">
                <div class="component-card">
                    <h3 class="text-xl font-semibold text-emerald-700 mb-2">오늘 배운 핵심 내용:</h3>
                    <ul class="list-disc list-inside space-y-1 text-sm">
                        <li>소리는 물체의 <strong class="text-amber-600">진동</strong>으로 발생하며, 진동 속도(주파수)에 따라 높낮이가 결정돼요.</li>
                        <li><strong class="text-amber-600">555 타이머</strong>는 규칙적인 신호를 만들어 소리의 기본 주파수를 생성해요.</li>
                        <li><strong class="text-amber-600">슈미트 트리거</strong>는 불안정한 신호를 깨끗한 사각파 펄스로 변환하여 소리를 명확하게 만들어줘요.</li>
                        <li><strong class="text-amber-600">OP-AMP</strong>는 작은 소리 신호를 크게 증폭시켜 우리가 들을 수 있게 해요.</li>
                        <li><strong class="text-amber-600">저항</strong>은 전류를 제어하고, <strong class="text-amber-600">가변저항</strong>으로 음높이를 조절하며, <strong class="text-amber-600">택트 스위치</strong>로 소리를 켜고 끌 수 있어요.</li>
                        <li>이 모든 부품들이 모여 신디사이저라는 악기가 된답니다!</li>
                    </ul>
                </div>
                 <div class="component-card">
                    <h3 class="text-xl font-semibold text-emerald-700 mb-2">학습 진행 팁 (from 교육과정):</h3>
                    <ul class="list-disc list-inside space-y-1 text-sm">
                        <li><strong>시각 자료 활용:</strong> 그림이나 애니메이션을 보면 이해가 더 쉬워요. (이 앱처럼요!)</li>
                        <li><strong>비유와 실생활 예시:</strong> 어려운 원리도 주변의 물건에 비유하면 재미있게 배울 수 있어요.</li>
                        <li><strong>질문은 언제나 환영:</strong> 궁금한 점이 있다면 주저하지 말고 질문하세요!</li>
                        <li><strong>직접 체험하기:</strong> 직접 만져보고 조작해보는 것이 최고의 학습 방법이에요.</li>
                        <li><strong>안전 제일:</strong> 전자 부품을 다룰 때는 항상 안전 수칙을 지켜주세요.</li>
                    </ul>
                </div>

                <!-- 슬라이드 섹션 시작: Canva 슬라이드 임베드 -->
                <div class="component-card">
                    <h3 class="text-xl font-semibold text-emerald-700 mb-4">사운드토이 큐브 01 학습 슬라이드</h3>
                    <div class="slide-container">
                        <!-- Canva 슬라이드를 임베드합니다. Canva embed 파라미터를 추가했습니다. -->
                        <iframe src="https://www.canva.com/design/DAGqPNWGerM/PETWQ8fUuKBvXzF0B287xw/view?embed" width="100%" height="100%" allowfullscreen allow="fullscreen" style="border: none; border-radius: 0.5rem; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);"> </iframe>
                    </div>
                    <p class="mt-4 text-center text-sm text-gray-600"> 위 슬라이드는 Canva에서 제공하는 임베드 기능을 사용하여 표시됩니다. 슬라이드 내에서 제공되는 컨트롤을 사용하여 탐색해주세요. </p>
                </div>
                <!-- Add the new slide here -->
                <div class="component-card">
                    <h3 class="text-xl font-semibold text-emerald-700 mb-4">사운드토이 큐브 02 학습 슬라이드</h3>
                    <div class="slide-container">
                        <iframe src="https://www.canva.com/design/DAGq2EFp4Bc/k5TPzkbMl7ZkRp8lxEVGRw/view?embed" width="100%" height="100%" allowfullscreen allow="fullscreen" style="border: none; border-radius: 0.5rem; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);">
                        </iframe>
                    </div>
                    <p class="mt-4 text-center text-sm text-gray-600"> 위 슬라이드는 Canva에서 제공하는 임베드 기능을 사용하여 표시됩니다. 슬라이드 내에서 제공되는 컨트롤을 사용하여 탐색해주세요. </p>
                </div>
                <!-- 슬라이드 섹션 끝 -->

                <p class="mt-4 text-center font-semibold">여러분의 창의력과 호기심으로 더 멋진 소리와 장치들을 만들어보세요! 🚀</p>
            </div>
        </div>
    </main>

    <footer class="text-center p-4 text-sm text-sky-800 mt-8">
        COPYRIGHT ‌TECHTREESPACE © 2017-2025. ALL RIGHTS RESERVED.
    </footer>

    <script>
        // 전역 변수 선언 및 초기화
        let audioContext;
        let oscillator; // 현재 재생 중인 오실레이터 (play/sound 섹션에서 사용)
        let gainNode;
        let isOscillatorRunning = false; // 오실레이터가 현재 재생 중인지 여부를 나타내는 플래그
        let tactSwitchAnimationFrameId = null; // 택트 스위치 애니메이션 프레임 ID (Hands 섹션에서만 사용)
        let selectedWaveformType = 'sine'; // 선택된 파형 타입을 저장하는 전역 변수 (Play 섹션에서 사용)
        let currentPulseWidth = 50; // 기본 듀티 사이클 (Play 섹션에서 사용)

        const sections = ['sound', 'heart', 'hands', 'play', 'summary'];
        const tabButtons = document.querySelectorAll('.tab-button');
        const contentSections = document.querySelectorAll('.content-section');
        let currentActiveSectionId = 'sound'; // 현재 활성화된 섹션 ID를 추적하는 변수

        // 애니메이션 프레임 ID를 저장하여 중지할 수 있도록 합니다.
        window.timerAnimationId = null;
        window.schmittAnimationId = null;
        window.handsAnimationId = null; // Hands 섹션 애니메이션 ID 추가

        // Mobile Navigation Elements
        const mobileMenuToggle = document.getElementById('mobile-menu-toggle');
        const mobileNavOverlay = document.getElementById('mobile-nav-overlay');
        const closeMobileMenu = document.getElementById('close-mobile-menu');
        const mobileNavLinks = document.querySelector('#mobile-nav-overlay .nav-links');

        mobileMenuToggle.addEventListener('click', () => {
            mobileNavOverlay.classList.add('open');
        });

        closeMobileMenu.addEventListener('click', () => {
            mobileNavOverlay.classList.remove('open');
        });

        mobileNavLinks.addEventListener('click', (event) => {
            // 이벤트 위임을 사용하여 탭 버튼 클릭 처리
            if (event.target.classList.contains('tab-button')) {
                // 클릭된 버튼의 섹션 ID를 가져와서 showSection 함수 호출
                const sectionId = event.target.onclick.toString().match(/showSection\('([^']+)'\)/)[1];
                showSection(sectionId);
                mobileNavOverlay.classList.remove('open'); // 메뉴 닫기
            }
        });


        function showSection(sectionId) {
            // 이전 활성 탭 버튼의 'active' 클래스 제거
            const prevActiveButton = document.querySelector(`.tab-button.active`);
            if (prevActiveButton) {
                prevActiveButton.classList.remove('active');
            }

            // 모든 content-section 숨기기
            contentSections.forEach(section => {
                section.classList.add('hidden');
            });

            // 선택된 content-section 보여주기
            const targetSection = document.getElementById(sectionId);
            if (targetSection) {
                targetSection.classList.remove('hidden');
            }

            // 현재 활성 탭 버튼에 'active' 클래스 추가 (데스크톱 및 모바일 메뉴 모두 적용)
            tabButtons.forEach(button => {
                if (button.onclick.toString().includes(`showSection('${sectionId}')`)) {
                    button.classList.add('active');
                }
            });

            currentActiveSectionId = sectionId; // 현재 활성화된 섹션 ID 업데이트
            console.log(`Switched to section: ${sectionId}`);

            // 섹션별 애니메이션 및 상태 관리
            // 모든 섹션 전환 시 현재 재생 중인 소리를 멈춥니다.
            stopTone();
            stopHandsAnimations();
            stopHeartAnimations();


            if (sectionId === 'sound') {
                setupWaveCanvas(); // 캔버스 크기 재설정 및 컨텍스트 다시 가져오기
                drawWave(parseInt(frequencySlider.value)); // 현재 슬라이더 값으로 파형 다시 그리기
                selectedWaveformType = 'sine'; // 사운드 섹션은 항상 사인파
            } else if (sectionId === 'play') {
                setupSynthCanvas();
                // 'play' 섹션으로 이동 시, 파형 타입을 UI의 기본 선택(sine)으로 맞춤
                const defaultWaveformRadio = document.querySelector('input[name="waveformType"][value="sine"]');
                if (defaultWaveformRadio) {
                    defaultWaveformRadio.checked = true; // UI에서 사인파를 기본으로 선택
                }
                selectedWaveformType = 'sine'; // 실제 오디오 파형 타입도 사인으로 설정
                console.log("Entered 'play' section, selectedWaveformType set to 'sine'");
                // 현재 선택된 파형(이제 'sine'이어야 함)에 따라 펄스 폭 조절 UI 표시/숨김
                const pulseWidthControlUI = document.getElementById('pulseWidthControl'); // 변수명 명확화
                if (selectedWaveformType === 'square') { // 초기값 'sine'이므로 hidden
                    pulseWidthControlUI.classList.remove('hidden');
                } else {
                    pulseWidthControlUI.classList.add('hidden');
                }
            } else if (sectionId === 'hands') {
                setupHandsCanvases(); // Added to ensure hands canvas is set up when section is shown
                startHandsAnimations();
                // hands 섹션에서 사용할 `selectedWaveformType`을 'square'로 고정
                // 이 변수는 playTone 함수에서 사용되므로 여기서 설정
                selectedWaveformType = 'square';
            } else if (sectionId === 'heart') {
                startHeartAnimations();
            } else if (sectionId === 'summary') {
                // summary 섹션 진입 시, 더 이상 custom slide setup을 호출할 필요가 없습니다.
                // Canva iframe이 이미 HTML에 있으므로 단순히 섹션을 표시하기만 하면 됩니다.
            }
        }

        const startExplorationButton = document.getElementById('start-exploration-button');
        const mainPageOverlay = document.getElementById('main-page-overlay');

        if (startExplorationButton) {
            startExplorationButton.addEventListener('click', () => {
                mainPageOverlay.classList.add('hidden');
                // Ensure audio context is initialized when user interacts for the first time
                initAudio();
            });
        }
        
        function initAudio() {
            if (!audioContext) {
                try {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    console.log('AudioContext initialized.');
                    gainNode = audioContext.createGain(); // 게인 노드 생성
                    gainNode.connect(audioContext.destination); // 게인 노드를 목적지에 연결
                } catch (e) {
                    console.error('Web Audio API not supported in this browser:', e);
                    alert('죄송합니다. 이 브라우저에서는 웹 오디오 API가 지원되지 않아 신디사이저 기능을 사용할 수 없습니다.');
                    return;
                }
            }
            // Ensure audio context is running, especially on iOS/Safari
            if (audioContext.state === 'suspended') {
                console.log('Attempting to resume AudioContext...');
                audioContext.resume().then(() => {
                    console.log('AudioContext resumed successfully.');
                    // Play a very short, silent tone to keep AudioContext active on mobile
                    if (audioContext.state === 'running') {
                        const silentOscillator = audioContext.createOscillator();
                        const silentGain = audioContext.createGain();
                        silentOscillator.connect(silentGain);
                        silentGain.connect(audioContext.destination);
                        silentGain.gain.setValueAtTime(0.00001, audioContext.currentTime); // Very low volume
                        silentOscillator.start(audioContext.currentTime);
                        silentOscillator.stop(audioContext.currentTime + 0.001); // Very short duration
                        console.log('Played silent tone to keep AudioContext active.');
                    }
                }).catch(e => {
                    console.error('Failed to resume AudioContext:', e);
                });
            } else if (audioContext.state === 'running') {
                console.log('AudioContext state is already active:', audioContext.state);
            }
            console.log('initAudio finished. Final AudioContext state:', audioContext.state);
        }

        // Helper function to create a PeriodicWave for a square wave with variable duty cycle
        function createSquarePeriodicWave(audioContext, dutyCycle) {
            const numHarmonics = 2048; // Number of harmonics
            const real = new Float32Array(numHarmonics + 1);
            const imag = new Float32Array(numHarmonics + 1);

            real[0] = 0; // DC component
            imag[0] = 0;

            for (let k = 1; k <= numHarmonics; k++) {
                const nPiD = k * Math.PI * dutyCycle;
                real[k] = (2 / (k * Math.PI)) * Math.sin(nPiD);
                imag[k] = (2 / (k * Math.PI)) * (1 - Math.cos(nPiD));
            }
            return audioContext.createPeriodicWave(real, imag, { disableNormalization: true });
        }

        /**
         * 지정된 주파수, 파형 타입, 듀티 사이클로 톤을 시작하거나 업데이트합니다.
         * 이미 오실레이터가 재생 중이고 파형 타입이 동일하면 주파수와 듀티 사이클만 업데이트합니다.
         * 파형 타입이 변경되거나 오실레이터가 없는 경우 새 오실레이터를 생성합니다.
         * @param {number} frequency - 톤의 주파수 (Hz).
         * @param {number} dutyCycle - 사각파의 듀티 사이클 (0.01 ~ 0.99).
         * @param {string} waveformType - 'sine', 'square', 'sawtooth', 'triangle' 중 하나.
         */
        async function playTone(frequency, dutyCycle = 0.5) {
            console.log(`playTone called: freq=${frequency}, waveform=${selectedWaveformType}, dutyCycle=${dutyCycle}`);
            await initAudio(); // 오디오 컨텍스트가 초기화되었는지 확인

            if (!audioContext || audioContext.state !== 'running') {
                console.warn('AudioContext is not running. Cannot play tone.');
                return;
            }

            const currentWaveformType = oscillator ? (oscillator.type === 'custom' ? 'square' : oscillator.type) : null;
            const needsNewOscillator = !oscillator || (selectedWaveformType !== currentWaveformType);

            if (needsNewOscillator) {
                // 기존 오실레이터가 있다면 정지하고 연결 해제 (새로운 시작을 위해)
                if (oscillator) {
                    try {
                        oscillator.stop();
                        oscillator.disconnect();
                        console.log("Old oscillator stopped and disconnected for new waveform type.");
                    } catch (e) {
                        console.warn("Could not stop or disconnect old oscillator, might have already stopped.", e);
                    }
                }
                oscillator = audioContext.createOscillator();
                oscillator.connect(gainNode);
                oscillator.start(audioContext.currentTime); // 현재 시간부터 시작
                console.log("New oscillator created and started.");

                // 볼륨 설정: 부드럽게 시작
                gainNode.gain.cancelScheduledValues(audioContext.currentTime);
                gainNode.gain.setValueAtTime(0.0001, audioContext.currentTime); // 0이 아닌 아주 작은 값에서 시작
                gainNode.gain.linearRampToValueAtTime(0.5, audioContext.currentTime + 0.05); // 50ms 동안 볼륨 업
            }

            // 파형 설정
            if (selectedWaveformType === 'square') {
                const periodicWave = createSquarePeriodicWave(audioContext, dutyCycle);
                oscillator.setPeriodicWave(periodicWave);
            } else {
                if (oscillator.type !== selectedWaveformType) { // 이미 custom이 아니거나, 타입이 다르면 설정
                    oscillator.type = selectedWaveformType;
                }
            }

            // 주파수 설정 (부드럽게 변경)
            if (isFinite(frequency) && frequency > 0) {
                oscillator.frequency.cancelScheduledValues(audioContext.currentTime);
                oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime); // 즉시 설정 (잡음 방지)
                // oscillator.frequency.linearRampToValueAtTime(frequency, audioContext.currentTime + 0.01); // 10ms 동안 부드럽게 변경
            } else {
                console.error("Invalid frequency value for playTone:", frequency);
                stopTone(); // 유효하지 않은 주파수면 소리 멈춤
                return;
            }

            isOscillatorRunning = true;
            console.log(`Oscillator parameters set: Type=${oscillator.type}, Freq=${frequency.toFixed(2)}, Duty=${dutyCycle}`);
        }

        // 오실레이터 정지 함수
        function stopTone() {
            console.log('stopTone called.');
            if (oscillator && isOscillatorRunning) {
                try {
                    gainNode.gain.cancelScheduledValues(audioContext.currentTime); // 예정된 모든 볼륨 변화 취소
                    gainNode.gain.setValueAtTime(gainNode.gain.value, audioContext.currentTime); // 현재 게인 값에서 시작
                    gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.05); // 50ms 동안 부드럽게 볼륨 감소
                    
                    const tempOsc = oscillator; // 참조 저장
                    tempOsc.stop(audioContext.currentTime + 0.05); // 볼륨 감소 후 정지 예약
                    tempOsc.onended = () => { // 정지 완료 시 콜백
                        tempOsc.disconnect();
                        console.log('Oscillator stopped and disconnected via onended.');
                    };
                } catch (e) {
                    console.warn("Error stopping oscillator:", e);
                }
            }
            oscillator = null; // 오실레이터 참조 제거
            isOscillatorRunning = false;
            console.log('stopTone finished. Oscillator is now:', oscillator);
        }


        // Section 1: Sound Canvas
        let waveCanvas, waveCtx;
        const frequencySlider = document.getElementById('frequencySlider');
        const frequencyValue = document.getElementById('frequencyValue');
        const pitchDescription = document.getElementById('pitchDescription');

        function drawWave(frequency) {
            if (!waveCtx || !waveCanvas) return;

            const width = waveCanvas.width;
            const height = waveCanvas.height;
            const amplitude = height / 3;
            const centerY = height / 2;

            waveCtx.clearRect(0, 0, width, height); // 캔버스 지우기
            waveCtx.beginPath(); // 새로운 경로 시작
            waveCtx.moveTo(0, centerY); // 시작점 설정

            // 사인파 그리기
            for (let x = 0; x < width; x++) {
                const y = centerY + amplitude * Math.sin((x * frequency * Math.PI * 2) / (width * 5));
                waveCtx.lineTo(x, y);
            }
            waveCtx.strokeStyle = 'rgb(59, 130, 246)'; // 파란색 선
            waveCtx.lineWidth = 2; // 선 두께
            waveCtx.stroke(); // 선 그리기
        }

        function setupWaveCanvas() {
            waveCanvas = document.getElementById('waveCanvas');
            if (waveCanvas) {
                waveCtx = waveCanvas.getContext('2d');
                const container = waveCanvas.parentElement;
                waveCanvas.width = container.clientWidth;
                waveCanvas.height = container.clientHeight;
                drawWave(parseInt(frequencySlider.value)); // 초기 파형 그리기
            }
        }

        frequencySlider.addEventListener('input', async (event) => {
            const freq = parseInt(event.target.value);
            frequencyValue.textContent = freq;
            drawWave(freq);
            if (freq < 7) pitchDescription.textContent = "낮은 음 (저주파)";
            else if (freq < 14) pitchDescription.textContent = "중간 음";
            else if (freq >= 14) pitchDescription.textContent = "높은 음 (고주파)";

            const audioFreq = 100 + (freq - 1) * 50;
            // 섹션 1에서는 항상 사인파로 소리내기 위해 타입 설정
            const originalSelectedWaveformType = selectedWaveformType; // 기존 파형 타입 저장
            selectedWaveformType = 'sine'; // 사인파로 강제 설정
            await playTone(audioFreq, 0.5); // 0.5 duty cycle (사인파에 큰 의미는 없지만 일관성을 위해)
            selectedWaveformType = originalSelectedWaveformType; // 원래 파형 타입으로 복원
        });

        frequencySlider.addEventListener('mouseup', stopTone);
        frequencySlider.addEventListener('touchend', stopTone);
        frequencySlider.addEventListener('mouseleave', stopTone);


        // Section 2: Heart Canvas (555 Timer, Schmitt Trigger)
        let timerAnimationCanvas, timerAnimationCtx;
        let schmittTriggerAnimationCanvas, schmittTriggerAnimationCtx;
        let animationTime = 0;
        const animationSpeed = 0.025; // 애니메이션 속도 조절 (기존 0.05에서 50% 느리게)

        function draw555TimerWave(ctx, canvas, time) {
            if (!ctx || !canvas) return;
            const width = canvas.width;
            const height = canvas.height;
            const amplitude = height / 3;
            const centerY = height / 2;

            ctx.clearRect(0, 0, width, height);
            ctx.beginPath();
            ctx.strokeStyle = '#EF4444'; // Red for 555 Timer
            ctx.lineWidth = 3;

            const cycleLength = width / 2; // 두 사이클을 그림
            const currentPosition = (time * animationSpeed * cycleLength) % cycleLength;

            for (let x = 0; x < width; x++) {
                const effectiveX = (x + currentPosition) % cycleLength;
                let y;
                if (effectiveX < cycleLength * 0.7) { // Duty cycle of approx 70%
                    y = centerY - amplitude;
                } else {
                    y = centerY + amplitude;
                }
                if (x === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();

            // 배경에 흐릿한 파형 추가
            ctx.beginPath();
            ctx.strokeStyle = 'rgba(239, 68, 68, 0.3)'; // Semi-transparent red
            ctx.lineWidth = 2;
            const bgOffset = currentPosition + cycleLength / 4; // 살짝 다른 위치에서 시작
            for (let x = 0; x < width; x++) {
                const effectiveX = (x + bgOffset) % cycleLength;
                let y;
                if (effectiveX < cycleLength * 0.6) { // 다른 듀티 사이클
                    y = centerY - amplitude * 0.8;
                } else {
                    y = centerY + amplitude * 0.8;
                }
                if (x === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();
        }

        function drawSchmittTriggerWave(ctx, canvas, time) {
            if (!ctx || !canvas) return;
            const width = canvas.width;
            const height = canvas.height;
            const amplitude = height / 3;
            const centerY = height / 2;

            ctx.clearRect(0, 0, width, height);
            ctx.beginPath();
            ctx.strokeStyle = '#10B981'; // Green for Schmitt Trigger
            ctx.lineWidth = 3;

            const cycleLength = width / 2; // 두 사이클을 그림
            const currentPosition = (time * animationSpeed * cycleLength) % cycleLength;

            // 입력 신호 (약간 노이즈 있는 사인파)
            ctx.beginPath();
            ctx.strokeStyle = 'rgba(16, 185, 129, 0.4)'; // Light green for input
            ctx.lineWidth = 1;
            for (let x = 0; x < width; x++) {
                const y = centerY + amplitude * 0.8 * Math.sin((x + currentPosition) * 0.1) + Math.random() * 10 - 5; // 노이즈 추가
                if (x === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();

            // 출력 신호 (깨끗한 사각파)
            ctx.beginPath();
            ctx.strokeStyle = '#10B981'; // Green
            ctx.lineWidth = 3;
            for (let x = 0; x < width; x++) {
                const effectiveX = (x + currentPosition) % cycleLength;
                let y;
                if (effectiveX < cycleLength / 2) {
                    y = centerY - amplitude;
                } else {
                    y = centerY + amplitude;
                }
                if (x === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();

            // 임계값 선
            ctx.strokeStyle = 'rgba(0,0,0,0.5)';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(0, centerY - amplitude * 0.4);
            ctx.lineTo(width, centerY - amplitude * 0.4);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(0, centerY + amplitude * 0.4);
            ctx.lineTo(width, centerY + amplitude * 0.4);
            ctx.stroke();
            ctx.setLineDash([]); // 다시 원래대로
        }

        function animateHeartWaves() {
            animationTime += 1;
            draw555TimerWave(timerAnimationCtx, timerAnimationCanvas, animationTime);
            drawSchmittTriggerWave(schmittTriggerAnimationCtx, schmittTriggerAnimationCanvas, animationTime);
            window.timerAnimationId = requestAnimationFrame(animateHeartWaves);
        }

        function setupHeartCanvases() {
            timerAnimationCanvas = document.getElementById('timerAnimationCanvas');
            schmittTriggerAnimationCanvas = document.getElementById('schmittTriggerAnimationCanvas');

            if (timerAnimationCanvas) {
                timerAnimationCtx = timerAnimationCanvas.getContext('2d');
                timerAnimationCanvas.width = timerAnimationCanvas.parentElement.clientWidth;
                timerAnimationCanvas.height = timerAnimationCanvas.parentElement.clientHeight;
            }
            if (schmittTriggerAnimationCanvas) {
                schmittTriggerAnimationCtx = schmittTriggerAnimationCanvas.getContext('2d');
                schmittTriggerAnimationCanvas.width = schmittTriggerAnimationCanvas.parentElement.clientWidth;
                schmittTriggerAnimationCtx.height = schmittTriggerAnimationCanvas.parentElement.clientHeight;
            }
        }

        function startHeartAnimations() {
            setupHeartCanvases();
            if (window.timerAnimationId === null) {
                animationTime = 0;
                animateHeartWaves();
            }

            const opampAnimation = document.getElementById('opampAnimation');
            if (opampAnimation && !opampAnimation.animationInterval) { // 중복 실행 방지
                let lm386SignalSize = 10;
                opampAnimation.animationInterval = setInterval(() => {
                    lm386SignalSize = lm386SignalSize === 10 ? 20 : 10;
                    opampAnimation.innerHTML = `신호 증폭 중... <span style="font-size:${lm386SignalSize}px">🔊</span>`;
                }, 750);
            }
        }

        function stopHeartAnimations() {
            if (window.timerAnimationId) {
                cancelAnimationFrame(window.timerAnimationId);
                window.timerAnimationId = null;
            }
            const opampAnimation = document.getElementById('opampAnimation');
            if (opampAnimation && opampAnimation.animationInterval) {
                clearInterval(opampAnimation.animationInterval);
                opampAnimation.innerHTML = `신호 증폭 중... (볼륨 업!)`;
                opampAnimation.animationInterval = null;
            }
        }

        window.addEventListener('load', async () => {
            setupWaveCanvas();
            setupSynthCanvas();
            setupHandsCanvases(); // Added to ensure hands canvas is set up on load
            showSection('sound');
            const mainPageOverlay = document.getElementById('main-page-overlay');
            if (mainPageOverlay) {
                mainPageOverlay.classList.remove('hidden');
            }
        });

        // Section 3: Hands (Potentiometer, Tact Switch)
        const potentiometerDemo = document.getElementById('potentiometerDemo');
        const potentiometerValue = document.getElementById('potentiometerValue');

        if (potentiometerDemo) {
            potentiometerDemo.addEventListener('input', async (event) => { // async 추가
                potentiometerValue.textContent = event.target.value;
                // 택트 스위치가 눌려있으면 소리도 업데이트
                if (isTactOn && currentActiveSectionId === 'hands') {
                    const potVal = parseInt(event.target.value);
                    const audioFreq = 200 + (potVal / 100) * 1000; // 200Hz to 1200Hz
                    // `handsCurrentPulseWidth`를 사용 (Hands 섹션 전용)
                    // 현재 selectedWaveformType이 play 섹션에 맞춰져 있을 수 있으므로, hands 섹션에선 'square'로 고정
                    const originalSelectedWaveformType = selectedWaveformType;
                    selectedWaveformType = 'square';
                    await playTone(audioFreq, handsCurrentPulseWidth / 100);
                    selectedWaveformType = originalSelectedWaveformType; // 원복
                }
            });
        }

        const tactSwitchDemo = document.getElementById('tactSwitchDemo');
        let isTactOn = false; // 택트 스위치 상태
        const tactSwitchStatus = document.getElementById('tactSwitchStatus');

        async function handleTactSwitch(on) {
            console.log(`handleTactSwitch called with on=${on}, isTactOn=${isTactOn}, currentActiveSectionId=${currentActiveSectionId}`);
            if (currentActiveSectionId !== 'hands') { // hands 섹션이 아니면 작동하지 않음
                console.log("Not in 'hands' section, ignoring tact switch.");
                return;
            }

            if (on && !isTactOn) {
                isTactOn = true;
                tactSwitchStatus.textContent = '스위치 상태: 켜짐 (소리 재생 중)';
                tactSwitchDemo.classList.add('bg-red-500', 'hover:bg-red-600');
                tactSwitchDemo.classList.remove('bg-sky-500', 'hover:bg-sky-600');
                
                const potVal = parseInt(potentiometerDemo.value);
                const audioFreq = 200 + (potVal / 100) * 1000;
                // `handsCurrentPulseWidth`를 사용 (Hands 섹션 전용)
                const originalSelectedWaveformType = selectedWaveformType;
                selectedWaveformType = 'square';
                await playTone(audioFreq, handsCurrentPulseWidth / 100);
                selectedWaveformType = originalSelectedWaveformType; // 원복

            } else if (!on && isTactOn) {
                isTactOn = false;
                tactSwitchStatus.textContent = '스위치 상태: 꺼짐 (마우스 클릭 또는 스페이스바 키로 조작)';
                tactSwitchDemo.classList.remove('bg-red-500', 'hover:bg-red-600');
                tactSwitchDemo.classList.add('bg-sky-500', 'hover:bg-sky-600');
                stopTone(); // 오실레이터 정지
            }
        }

        tactSwitchDemo.addEventListener('mousedown', (event) => {
            console.log('Tact switch mousedown event fired.');
            event.preventDefault();
            handleTactSwitch(true);
        });
        tactSwitchDemo.addEventListener('mouseup', () => handleTactSwitch(false));
        tactSwitchDemo.addEventListener('mouseleave', () => {
            if (isTactOn) handleTactSwitch(false);
        });

        tactSwitchDemo.addEventListener('touchstart', (event) => {
            console.log('Tact switch touchstart event fired.');
            event.preventDefault();
            handleTactSwitch(true);
        }, { passive: false });
        tactSwitchDemo.addEventListener('touchend', () => {
            console.log('Tact switch touchend event fired.');
            handleTactSwitch(false);
        });

        let isSpaceOrEnterPressed = false;
        document.addEventListener('keydown', async (event) => {
            if (currentActiveSectionId === 'hands' && (event.key === ' ' || event.key === 'Enter') && !isSpaceOrEnterPressed) {
                event.preventDefault();
                isSpaceOrEnterPressed = true;
                handleTactSwitch(true);
            }
        });

        document.addEventListener('keyup', (event) => {
            if (currentActiveSectionId === 'hands' && (event.key === ' ' || event.key === 'Enter') && isSpaceOrEnterPressed) {
                isSpaceOrEnterPressed = false;
                handleTactSwitch(false);
            }
        });

        // Section 4: Play (Synth Simulator)
        let synthPitchKnob = document.getElementById('synthPitchKnob');
        let synthPitchValue = document.getElementById('synthPitchValue');
        const synthButtons = document.querySelectorAll('.synth-button');
        let synthOutputStatus = document.getElementById('synthOutputStatus');
        
        let synthOutputCanvas;
        let synthCtx;

        const pulseWidthControl = document.getElementById('pulseWidthControl');
        const pulseWidthKnob = document.getElementById('pulseWidthKnob');
        const pulseWidthValue = document.getElementById('pulseWidthValue');
        // `currentPulseWidth`는 이제 전역 변수로 최상단에 선언됩니다.

        function drawSynthWave(frequency, waveformType, dutyCycle = 0.5) {
            if (!synthCtx || !synthOutputCanvas) {
                console.warn('synthOutputCanvas or synthCtx is not initialized in drawSynthWave.');
                return;
            }

            const width = synthOutputCanvas.width;
            const height = synthOutputCanvas.height;
            const amplitude = height / 3;
            const centerY = height / 2;

            synthCtx.clearRect(0, 0, width, height);
            synthCtx.beginPath();
            synthCtx.moveTo(0, centerY);

            // 주파수가 0이면 파형을 그리지 않음 (소리가 나지 않는 상태 표현)
            if (frequency === 0) {
                synthCtx.strokeStyle = 'rgba(16, 185, 129, 0.3)'; // 흐릿하게
                synthCtx.lineWidth = 1;
                synthCtx.font = '16px Inter';
                synthCtx.fillStyle = 'rgba(16, 185, 129, 0.6)';
                synthCtx.textAlign = 'center';
                synthCtx.fillText('소리가 재생되지 않고 있습니다.', width / 2, height / 2);
                synthCtx.stroke();
                return;
            }


            const numCycles = 2; // 화면에 2주기 표시
            const totalWidthPerCycle = width / numCycles;

            for (let x = 0; x < width; x++) {
                let y;
                // 주파수를 시각화에 맞게 조정 (너무 빠르면 파형이 뭉개짐)
                // 실제 주파수 값에 비례하여 시각화 주기 결정
                const effectiveFrequencyForViz = Math.max(1, Math.min(1000, frequency / 10)); // 시각화 범위를 적절히 제한
                const angle = (x / width) * Math.PI * 2 * (effectiveFrequencyForViz / 50); // 50은 시각적 기준 주파수

                switch (waveformType) {
                    case 'sine':
                        y = centerY + amplitude * Math.sin(angle);
                        break;
                    case 'square':
                        const phaseForSquare = (x / totalWidthPerCycle * (2 * Math.PI)) % (2 * Math.PI);
                        const onDurationSquare = (2 * Math.PI) * dutyCycle;
                        if (phaseForSquare < onDurationSquare) {
                            y = centerY - amplitude;
                        } else {
                            y = centerY + amplitude;
                        }
                        break;
                    case 'sawtooth':
                        y = centerY - amplitude * ((angle % (2 * Math.PI)) / (2 * Math.PI) * 2 - 1);
                        break;
                    case 'triangle':
                        const phaseForTriangle = angle % (2 * Math.PI);
                        if (phaseForTriangle < Math.PI) {
                            y = centerY - amplitude * (1 - (phaseForTriangle / Math.PI) * 2);
                        } else {
                            y = centerY - amplitude * (-1 + ((phaseForTriangle - Math.PI) / Math.PI) * 2);
                        }
                        break;
                    default:
                        y = centerY + amplitude * Math.sin(angle);
                }
                synthCtx.lineTo(x, y);
            }
            synthCtx.strokeStyle = 'rgb(16, 185, 129)';
            synthCtx.lineWidth = 2;
            synthCtx.stroke();
        }

        function setupSynthCanvas() {
            synthOutputCanvas = document.getElementById('synthOutputCanvas');
            if (synthOutputCanvas) {
                synthCtx = synthOutputCanvas.getContext('2d');
                const container = synthOutputCanvas.parentElement;
                synthOutputCanvas.width = container.clientWidth;
                synthOutputCanvas.height = container.clientHeight;
                drawSynthWave(0, selectedWaveformType, currentPulseWidth);
            }
        }

        // Hands section specific canvas (Pulse Width)
        const handsPulseWidthKnob = document.getElementById('handsPulseWidthKnob');
        const handsPulseWidthValue = document.getElementById('handsPulseWidthValue');
        let handsPulseWidthCanvas;
        let handsPulseWidthCtx;
        let handsCurrentPulseWidth = 50; // Default for hands pulse width
        let handsAnimationTime = 0;

        function drawHandsPulseWave(dutyCycle, time) {
            if (!handsPulseWidthCtx || !handsPulseWidthCanvas) {
                console.warn('handsPulseWidthCanvas or handsPulseWidthCtx is not initialized in drawHandsPulseWave.');
                return;
            }
            const width = handsPulseWidthCanvas.width;
            const height = handsPulseWidthCanvas.height;
            const amplitude = height / 3;
            const centerY = height / 2;
            const flowSpeed = 0.25; // 애니메이션 속도 조절 (기존 0.5에서 50% 느리게)
            const visualCycles = 2;
            const totalPixelsPerCycle = width / visualCycles;
            const onWidth = totalPixelsPerCycle * (dutyCycle / 100);
            const offset = (time * flowSpeed * totalPixelsPerCycle / (2 * Math.PI)) % totalPixelsPerCycle;

            handsPulseWidthCtx.clearRect(0, 0, width, height);
            handsPulseWidthCtx.beginPath();

            const initialAdjustedX = offset % totalPixelsPerCycle;
            const initialY = (initialAdjustedX < onWidth) ? (centerY - amplitude) : (centerY + amplitude);
            handsPulseWidthCtx.moveTo(0, initialY);

            for (let x = 1; x <= width; x++) {
                const adjustedX = (x + offset) % totalPixelsPerCycle;
                const prevAdjustedX = ((x - 1) + offset) % totalPixelsPerCycle;
                const currentY = (adjustedX < onWidth) ? (centerY - amplitude) : (centerY + amplitude);
                const prevY = (prevAdjustedX < onWidth) ? (centerY - amplitude) : (centerY + amplitude);
                if (currentY !== prevY) {
                    handsPulseWidthCtx.lineTo(x, prevY);
                    handsPulseWidthCtx.lineTo(x, currentY);
                } else {
                    handsPulseWidthCtx.lineTo(x, currentY);
                }
            }

            handsPulseWidthCtx.strokeStyle = 'rgb(139, 92, 246)'; // Purple
            handsPulseWidthCtx.lineWidth = 2;
            handsPulseWidthCtx.stroke();
        }

        function setupHandsCanvases() {
            handsPulseWidthCanvas = document.getElementById('handsPulseWidthCanvas');
            if (handsPulseWidthCanvas) {
                handsPulseWidthCtx = handsPulseWidthCanvas.getContext('2d');
                handsPulseWidthCanvas.width = handsPulseWidthCanvas.parentElement.clientWidth;
                handsPulseWidthCanvas.height = handsPulseWidthCanvas.parentElement.clientHeight;
                drawHandsPulseWave(handsCurrentPulseWidth, handsAnimationTime);
            }
        }

        function animateHandsWaves() {
            handsAnimationTime += 0.1;
            if (handsPulseWidthCtx && handsPulseWidthCanvas) {
                drawHandsPulseWave(handsCurrentPulseWidth, handsAnimationTime);
            }
            window.handsAnimationId = requestAnimationFrame(animateHandsWaves);
        }

        function startHandsAnimations() {
            setupHandsCanvases();
            if (window.handsAnimationId === null) {
                handsAnimationTime = 0;
                animateHandsWaves();
            }
        }

        function stopHandsAnimations() {
            if (window.handsAnimationId) {
                cancelAnimationFrame(window.handsAnimationId);
                window.handsAnimationId = null;
            }
        }

        if (handsPulseWidthKnob) {
            handsPulseWidthKnob.addEventListener('input', async (event) => {
                handsCurrentPulseWidth = parseInt(event.target.value);
                handsPulseWidthValue.textContent = handsCurrentPulseWidth;
                console.log(`Hands Pulse Width Slider Input: ${handsCurrentPulseWidth}, isTactOn: ${isTactOn}, currentActiveSectionId: ${currentActiveSectionId}`);

                drawHandsPulseWave(handsCurrentPulseWidth, handsAnimationTime);

                if (isTactOn && currentActiveSectionId === 'hands') {
                    console.log('Tact switch is ON in Hands section. Updating audio with duty cycle:', handsCurrentPulseWidth / 100);
                    const potVal = parseInt(potentiometerDemo.value);
                    const audioFreq = 200 + (potVal / 100) * 1000;
                    // 'square' 파형으로 고정하여 재생
                    const originalSelectedWaveformType = selectedWaveformType;
                    selectedWaveformType = 'square'; // Temporarily set for playTone
                    await playTone(audioFreq, handsCurrentPulseWidth / 100);
                    selectedWaveformType = originalSelectedWaveformType; // Restore original
                }
            });
        }
        
        const noteFrequencies = {
            'C5': 523.25, 'D5': 587.33, 'E5': 659.25, 'F5': 698.46, 'G5': 783.99, 'A5': 880.00, 'B5': 987.77,
            'C4': 261.63, 'D4': 293.66, 'E4': 329.63, 'F4': 349.23, 'G4': 392.00, 'A4': 440.00, 'B4': 493.88
        };
        let currentPlayingBaseFreq = 0; // 현재 연주 중인 건반의 기본 주파수

        synthPitchKnob.addEventListener('input', async (event) => {
            const pitch = parseInt(event.target.value);
            synthPitchValue.textContent = pitch;

            if (isOscillatorRunning && currentPlayingBaseFreq !== 0) {
                const pitchMultiplier = 0.5 + (pitch / 100) * 1.5;
                const finalFreq = currentPlayingBaseFreq * pitchMultiplier;
                
                if (isFinite(finalFreq) && finalFreq > 0) { // 주파수가 유효한지 확인
                    // 오실레이터가 이미 실행 중이면 파형 타입 변경 없이 주파수만 업데이트
                    if (oscillator) {
                        oscillator.frequency.cancelScheduledValues(audioContext.currentTime);
                        oscillator.frequency.setValueAtTime(finalFreq, audioContext.currentTime);
                    }
                    drawSynthWave(finalFreq, selectedWaveformType, currentPulseWidth); // 파형 시각화 업데이트
                } else {
                    console.error("Invalid finalFreq value from pitch knob:", finalFreq);
                    stopTone();
                    return;
                }
                
                // 현재 활성화된 건반의 상태 메시지 업데이트
                const activeNoteButton = document.querySelector('.synth-button.ring-4');
                if (activeNoteButton) {
                    const noteFull = activeNoteButton.dataset.noteFull;
                    const noteName = noteFull.slice(0, -1);
                    const octave = parseInt(noteFull.slice(-1));
                    const noteTextMap = { 'C': '도', 'D': '레', 'E': '미', 'F': '파', 'G': '솔', 'A': '라', 'B': '시' };
                    const displayNote = `${noteTextMap[noteName]}${octave - 3}`;

                    synthOutputStatus.textContent = `${displayNote} 음 (${selectedWaveformType}파) 재생! (주파수: ${finalFreq.toFixed(2)} Hz)`;
                }
            } else {
                // 소리가 재생 중이 아니면, 시각화만 업데이트 (주파수 0으로)
                if (currentActiveSectionId === 'play') {
                    drawSynthWave(0, selectedWaveformType, currentPulseWidth);
                }
            }
        });

        const waveformRadios = document.querySelectorAll('input[name="waveformType"]');
        waveformRadios.forEach(radio => {
            radio.addEventListener('change', async (event) => {
                selectedWaveformType = event.target.value;
                console.log(`Waveform changed to: ${selectedWaveformType}`);


                if (selectedWaveformType === 'square') {
                    pulseWidthControl.classList.remove('hidden');
                } else {
                    pulseWidthControl.classList.add('hidden');
                }

                if (isOscillatorRunning && currentPlayingBaseFreq !== 0) { // 현재 소리가 재생 중이면 파형 즉시 변경
                    const pitch = parseInt(synthPitchKnob.value);
                    const finalFreq = currentPlayingBaseFreq * (0.5 + (pitch / 100) * 1.5);
                    await playTone(finalFreq, currentPulseWidth / 100); // 새로운 파형으로 재생
                    // 상태 텍스트 및 파형도 업데이트
                    const activeNoteButton = document.querySelector('.synth-button.ring-4');
                     if (activeNoteButton) {
                        const noteFull = activeNoteButton.dataset.noteFull;
                        const noteName = noteFull.slice(0, -1);
                        const octave = parseInt(noteFull.slice(-1));
                        const noteTextMap = { 'C': '도', 'D': '레', 'E': '미', 'F': '파', 'G': '솔', 'A': '라', 'B': '시' };
                        const displayNote = `${noteTextMap[noteName]}${octave - 3}`;
                        synthOutputStatus.textContent = `${displayNote} 음 (${selectedWaveformType}파) 재생! (주파수: ${finalFreq.toFixed(2)} Hz)`;
                        drawSynthWave(finalFreq, selectedWaveformType, currentPulseWidth);
                    }

                } else { // 소리가 재생 중이 아니면, 시각화만 업데이트
                    if (currentActiveSectionId === 'play') {
                        drawSynthWave(0, selectedWaveformType, currentPulseWidth);
                    }
                }
            });
        });

        pulseWidthKnob.addEventListener('input', async (event) => {
            currentPulseWidth = parseInt(event.target.value);
            pulseWidthValue.textContent = currentPulseWidth;

            if (isOscillatorRunning && currentPlayingBaseFreq !== 0) {
                const pitch = parseInt(synthPitchKnob.value);
                const finalFreq = currentPlayingBaseFreq * (0.5 + (pitch / 100) * 1.5);
                drawSynthWave(finalFreq, selectedWaveformType, currentPulseWidth); // 시각화는 항상 업데이트
                if (selectedWaveformType === 'square') { // 사각파일 때만 오디오 업데이트
                    // 오실레이터가 이미 사각파라면 setPeriodicWave로 듀티 사이클만 업데이트
                    if (oscillator && oscillator.type === 'custom') {
                        const periodicWave = createSquarePeriodicWave(audioContext, currentPulseWidth / 100);
                        oscillator.setPeriodicWave(periodicWave);
                    } else { // 사각파가 아니었다면 새로 생성하여 사각파로 변경
                        await playTone(finalFreq, currentPulseWidth / 100);
                    }
                }
            } else {
                if (selectedWaveformType === 'square' && currentActiveSectionId === 'play') {
                     drawSynthWave(0, selectedWaveformType, currentPulseWidth);
                }
            }
        });

        const noteHueMap = {
            'C': 0, 'D': 30, 'E': 60, 'F': 120, 'G': 240, 'A': 270, 'B': 300
        };
        const octaveLightness = {
            '5': 80, // Higher octave, brighter
            '4': 60  // Lower octave, slightly darker
        };
        const fixedSaturation = 80;

        function getNoteGradient(noteFull) {
            const noteName = noteFull.slice(0, -1);
            const octave = noteFull.slice(-1);
            const hue = noteHueMap[noteName] || 0;
            const lightness = octaveLightness[octave] || 70; // Default lightness

            const startColor = `hsl(${hue}, ${fixedSaturation}%, ${lightness}%)`;
            const endColor = `hsl(${hue}, ${fixedSaturation}%, ${lightness - 20}%)`; // Darker end

            return `linear-gradient(to bottom, ${startColor}, ${endColor})`;
        }


        synthButtons.forEach(button => {
            const noteFull = button.dataset.noteFull;
            button.style.background = getNoteGradient(noteFull);

            button.addEventListener('mousedown', async (event) => {
                console.log('Synth button mousedown event fired for:', button.dataset.noteFull);
                event.preventDefault(); // Prevent text selection
                const noteFull = button.dataset.noteFull;
                const pitch = parseInt(synthPitchKnob.value);
                
                let baseFreq = noteFrequencies[noteFull];
                currentPlayingBaseFreq = baseFreq; // Save the base frequency for pitch knob adjustment

                const pitchMultiplier = 0.5 + (pitch / 100) * 1.5;
                const finalFreq = baseFreq * pitchMultiplier;

                // 다른 버튼의 활성 표시 제거 및 현재 버튼에 활성 표시 추가
                document.querySelectorAll('.synth-button.ring-4').forEach(b => {
                    b.classList.remove('ring-4', 'ring-blue-500', 'scale-105');
                });
                button.classList.add('ring-4', 'ring-blue-500', 'scale-105');

                const noteName = noteFull.slice(0, -1);
                const octave = parseInt(noteFull.slice(-1));
                const noteTextMap = { 'C': '도', 'D': '레', 'E': '미', 'F': '파', 'G': '솔', 'A': '라', 'B': '시' };
                const displayNote = `${noteTextMap[noteName]}${octave - 3}`;

                synthOutputStatus.textContent = `${displayNote} 음 (${selectedWaveformType}파) 재생! (주파수: ${finalFreq.toFixed(2)} Hz)`;
                drawSynthWave(finalFreq, selectedWaveformType, currentPulseWidth);
                await playTone(finalFreq, currentPulseWidth / 100);
            });

            button.addEventListener('mouseup', () => {
                console.log('Synth button mouseup event fired.');
                stopTone();
                button.classList.remove('ring-4', 'ring-blue-500', 'scale-105');
                synthOutputStatus.textContent = '버튼을 눌러 연주해보세요!';
                drawSynthWave(0, selectedWaveformType, currentPulseWidth); // Reset visualization
                currentPlayingBaseFreq = 0; // Reset base frequency
            });

            button.addEventListener('mouseleave', () => {
                console.log('Synth button mouseleave event fired.');
                // 마우스가 버튼을 벗어났을 때, 버튼이 눌려있던 상태였다면 소리 정지
                if (button.classList.contains('ring-4')) {
                    stopTone();
                    button.classList.remove('ring-4', 'ring-blue-500', 'scale-105');
                    synthOutputStatus.textContent = '버튼을 눌러 연주해보세요!';
                    drawSynthWave(0, selectedWaveformType, currentPulseWidth); // Reset visualization
                    currentPlayingBaseFreq = 0;
                }
            });

            // Touch events for mobile
            button.addEventListener('touchstart', async (event) => {
                console.log('Synth button touchstart event fired for:', button.dataset.noteFull);
                event.preventDefault(); // Prevent scrolling and default touch behavior
                const noteFull = button.dataset.noteFull;
                const pitch = parseInt(synthPitchKnob.value);

                let baseFreq = noteFrequencies[noteFull];
                currentPlayingBaseFreq = baseFreq;

                const pitchMultiplier = 0.5 + (pitch / 100) * 1.5;
                const finalFreq = baseFreq * pitchMultiplier;

                document.querySelectorAll('.synth-button.ring-4').forEach(b => {
                    b.classList.remove('ring-4', 'ring-blue-500', 'scale-105');
                });
                button.classList.add('ring-4', 'ring-blue-500', 'scale-105');

                const noteName = noteFull.slice(0, -1);
                const octave = parseInt(noteFull.slice(-1));
                const noteTextMap = { 'C': '도', 'D': '레', 'E': '미', 'F': '파', 'G': '솔', 'A': '라', 'B': '시' };
                const displayNote = `${noteTextMap[noteName]}${octave - 3}`;
                synthOutputStatus.textContent = `${displayNote} 음 (${selectedWaveformType}파) 재생! (주파수: ${finalFreq.toFixed(2)} Hz)`;
                drawSynthWave(finalFreq, selectedWaveformType, currentPulseWidth);
                await playTone(finalFreq, currentPulseWidth / 100);
            }, { passive: false });

            button.addEventListener('touchend', () => {
                console.log('Synth button touchend event fired.');
                stopTone();
                button.classList.remove('ring-4', 'ring-blue-500', 'scale-105');
                synthOutputStatus.textContent = '버튼을 눌러 연주해보세요!';
                drawSynthWave(0, selectedWaveformType, currentPulseWidth);
                currentPlayingBaseFreq = 0;
            });
        });

        // Keyboard control for synth (Play 섹션에서는 제거됨)
        // const keyboardNoteMap = { ... };
        // let activeKeys = {};
        // document.addEventListener('keydown', async (event) => { /* ... */ });
        // document.addEventListener('keyup', (event) => { /* ... */ });


        document.addEventListener('DOMContentLoaded', () => {
            const sineRadioPlay = document.querySelector('#play input[name="waveformType"][value="sine"]');
            const pulseWidthControlUI = document.getElementById('pulseWidthControl');
            if (sineRadioPlay && sineRadioPlay.checked) { // play 섹션의 사인파가 기본 체크되어 있다면
                 if(pulseWidthControlUI) pulseWidthControlUI.classList.add('hidden');
            }


            showSection(currentActiveSectionId); 
        });

        window.addEventListener('resize', () => {
            if (currentActiveSectionId === 'sound') {
                setupWaveCanvas();
                drawWave(parseInt(frequencySlider.value));
            } else if (currentActiveSectionId === 'heart') {
                setupHeartCanvases();
            } else if (currentActiveSectionId === 'hands') {
                setupHandsCanvases(); // Ensure setup is called on resize
                drawHandsPulseWave(handsCurrentPulseWidth, handsAnimationTime); 
            } else if (currentActiveSectionId === 'play') {
                setupSynthCanvas();
                const activeNoteButton = document.querySelector('.synth-button.ring-4');
                let freqToDraw = 0;
                if (activeNoteButton && currentPlayingBaseFreq !== 0) {
                    const pitch = parseInt(synthPitchKnob.value);
                    freqToDraw = currentPlayingBaseFreq * (0.5 + (pitch / 100) * 1.5);
                }
                drawSynthWave(freqToDraw, selectedWaveformType, currentPulseWidth);
            } 
            // 'summary' 섹션에 대한 resize 핸들링은 iframe이 자체적으로 반응형을 처리하므로 제거
        });

    // --- 기존 슬라이드 기능 관련 JavaScript 제거 또는 주석 처리 ---
    // 기존 슬라이드 기능 관련 변수들은 사용되지 않으므로 제거합니다.
    // let currentSlide = 0;
    // const slidesContainer = document.getElementById('circuit-slides');
    // const slidePages = slidesContainer ? slidesContainer.querySelectorAll('.slide-page') : [];
    // const totalSlides = slidePages.length;
    // const prevButton = document.getElementById('prevSlide');
    // const nextButton = document.getElementById('nextSlide');
    // const slideIndicatorsContainer = document.getElementById('slideIndicators');

    // // 기존 슬라이드 제어 함수들은 사용되지 않으므로 제거합니다.
    // function showSlide(index) { /* ... */ }
    // function nextSlide() { /* ... */ }
    // function prevSlide() { /* ... */ }
    // function createIndicators() { /* ... */ }
    // function updateIndicators() { /* ... */ }

    // setupSlides 함수는 이제 필요 없으므로 제거합니다.
    // function setupSlides() {
    //     if (slidesContainer) {
    //         showSlide(currentSlide);
    //         createIndicators();
    //     }
    // }

    // 슬라이드 네비게이션 버튼 이벤트 리스너도 제거합니다.
    // if (prevButton) { prevButton.addEventListener('click', prevSlide); }
    // if (nextButton) { nextButton.addEventListener('click', nextSlide); }

    // DOMContentLoaded에서 setupSlides 호출도 제거합니다.
    // document.addEventListener('DOMContentLoaded', setupSlides);

    </script>
</body>
</html>
